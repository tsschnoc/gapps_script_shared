{"ts":1358843837343,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// Copyright 2011 Mark Cavage, Inc.  All rights reserved.\n\nvar assert = require('assert');\nvar EventEmitter = require('events').EventEmitter;\nvar net = require('net');\nvar tls = require('tls');\nvar util = require('util');\n\nvar asn1 = require('asn1');\n\nvar dn = require('./dn');\nvar dtrace = require('./dtrace');\nvar errors = require('./errors');\nvar Protocol = require('./protocol');\n\nvar Parser = require('./messages').Parser;\nvar AbandonResponse = require('./messages/abandon_response');\nvar AddResponse = require('./messages/add_response');\nvar BindResponse = require('./messages/bind_response');\nvar CompareResponse = require('./messages/compare_response');\nvar DeleteResponse = require('./messages/del_response');\nvar ExtendedResponse = require('./messages/ext_response');\nvar LDAPResult = require('./messages/result');\nvar ModifyResponse = require('./messages/modify_response');\nvar ModifyDNResponse = require('./messages/moddn_response');\nvar SearchRequest = require('./messages/search_request');\nvar SearchResponse = require('./messages/search_response');\nvar UnbindResponse = require('./messages/unbind_response');\n\n\n\n///--- Globals\n\nvar Ber = asn1.Ber;\nvar BerReader = asn1.BerReader;\nvar DN = dn.DN;\n\nvar sprintf = util.format;\n\n\n///--- Helpers\n\nfunction mergeFunctionArgs(argv, start, end) {\n  assert.ok(argv);\n\n  if (!start)\n    start = 0;\n  if (!end)\n    end = argv.length;\n\n  var handlers = [];\n\n  for (var i = start; i < end; i++) {\n    if (argv[i] instanceof Array) {\n      var arr = argv[i];\n      for (var j = 0; j < arr.length; j++) {\n        if (!(arr[j] instanceof Function)) {\n          throw new TypeError('Invalid argument type: ' + typeof (arr[j]));\n        }\n        handlers.push(arr[j]);\n      }\n    } else if (argv[i] instanceof Function) {\n      handlers.push(argv[i]);\n    } else {\n      throw new TypeError('Invalid argument type: ' + typeof (argv[i]));\n    }\n  }\n\n  return handlers;\n}\n\n\nfunction getResponse(req) {\n  assert.ok(req);\n\n  var Response;\n\n  switch (req.protocolOp) {\n  case Protocol.LDAP_REQ_BIND:\n    Response = BindResponse;\n    break;\n  case Protocol.LDAP_REQ_ABANDON:\n    Response = AbandonResponse;\n    break;\n  case Protocol.LDAP_REQ_ADD:\n    Response = AddResponse;\n    break;\n  case Protocol.LDAP_REQ_COMPARE:\n    Response = CompareResponse;\n    break;\n  case Protocol.LDAP_REQ_DELETE:\n    Response = DeleteResponse;\n    break;\n  case Protocol.LDAP_REQ_EXTENSION:\n    Response = ExtendedResponse;\n    break;\n  case Protocol.LDAP_REQ_MODIFY:\n    Response = ModifyResponse;\n    break;\n  case Protocol.LDAP_REQ_MODRDN:\n    Response = ModifyDNResponse;\n    break;\n  case Protocol.LDAP_REQ_SEARCH:\n    Response = SearchResponse;\n    break;\n  case Protocol.LDAP_REQ_UNBIND:\n    Response = UnbindResponse;\n    break;\n  default:\n    return null;\n  }\n  assert.ok(Response);\n\n  var res = new Response({\n    messageID: req.messageID,\n    log: req.log,\n    attributes: ((req instanceof SearchRequest) ? req.attributes : undefined)\n  });\n  res.connection = req.connection;\n  res.logId = req.logId;\n\n  return res;\n}\n\n\nfunction defaultHandler(req, res, next) {\n  assert.ok(req);\n  assert.ok(res);\n  assert.ok(next);\n\n  res.matchedDN = req.dn.toString();\n  res.errorMessage = 'Server method not implemented';\n  res.end(errors.LDAP_OTHER);\n  return next();\n}\n\n\nfunction defaultNoOpHandler(req, res, next) {\n  assert.ok(req);\n  assert.ok(res);\n  assert.ok(next);\n\n  res.end();\n  return next();\n}\n\n\nfunction noSuffixHandler(req, res, next) {\n  assert.ok(req);\n  assert.ok(res);\n  assert.ok(next);\n\n  res.errorMessage = 'No tree found for: ' + req.dn.toString();\n  res.end(errors.LDAP_NO_SUCH_OBJECT);\n  return next();\n}\n\n\nfunction noExOpHandler(req, res, next) {\n  assert.ok(req);\n  assert.ok(res);\n  assert.ok(next);\n\n  res.errorMessage = req.requestName + ' not supported';\n  res.end(errors.LDAP_PROTOCOL_ERROR);\n  return next();\n}\n\n\nfunction fireDTraceProbe(req, res) {\n  assert.ok(req);\n\n  req._dtraceId = res._dtraceId = dtrace._nextId();\n  var probeArgs = [\n    req._dtraceId,\n    req.connection.remoteAddress || 'localhost',\n    req.connection.ldap.bindDN.toString(),\n    req.dn.toString()\n  ];\n\n  var op;\n  switch (req.protocolOp) {\n  case Protocol.LDAP_REQ_ABANDON:\n    op = 'abandon';\n    break;\n  case Protocol.LDAP_REQ_ADD:\n    op = 'add';\n    probeArgs.push(req.attributes.length);\n    break;\n  case Protocol.LDAP_REQ_BIND:\n    op = 'bind';\n    break;\n  case Protocol.LDAP_REQ_COMPARE:\n    op = 'compare';\n    probeArgs.push(req.attribute);\n    probeArgs.push(req.value);\n    break;\n  case Protocol.LDAP_REQ_DELETE:\n    op = 'delete';\n    break;\n  case Protocol.LDAP_REQ_EXTENSION:\n    op = 'exop';\n    probeArgs.push(req.name);\n    probeArgs.push(req.value);\n    break;\n  case Protocol.LDAP_REQ_MODIFY:\n    op = 'modify';\n    probeArgs.push(req.changes.length);\n    break;\n  case Protocol.LDAP_REQ_MODRDN:\n    op = 'modifydn';\n    probeArgs.push(req.newRdn.toString());\n    probeArgs.push((req.newSuperior ? req.newSuperior.toString() : ''));\n    break;\n  case Protocol.LDAP_REQ_SEARCH:\n    op = 'search';\n    probeArgs.push(req.scope);\n    probeArgs.push(req.filter.toString());\n    break;\n  case Protocol.LDAP_REQ_UNBIND:\n    op = 'unbind';\n    break;\n  default:\n    break;\n  }\n\n  res._dtraceOp = op;\n  dtrace.fire('server-' + op + '-start', function () {\n    return probeArgs;\n  });\n}\n\n\n\n///--- API\n\n/**\n * Constructs a new server that you can call .listen() on, in the various\n * forms node supports.  You need to first assign some handlers to the various\n * LDAP operations however.\n *\n * The options object currently only takes a certificate/private key, and a\n * bunyan logger handle.\n *\n * This object exposes the following events:\n *  - 'error'\n *  - 'close'\n *\n * @param {Object} options (optional) parameterization object.\n * @throws {TypeError} on bad input.\n */\nfunction Server(options) {\n  if (options) {\n    if (typeof (options) !== 'object')\n      throw new TypeError('options (object) required');\n    if (typeof (options.log) !== 'object')\n      throw new TypeError('options.log must be an object');\n\n    if (options.certificate || options.key) {\n      if (!(options.certificate && options.key) ||\n          typeof (options.certificate) !== 'string' ||\n          typeof (options.key) !== 'string') {\n        throw new TypeError('options.certificate and options.key (string) ' +\n                            'are both required for TLS');\n      }\n    }\n  } else {\n    options = {};\n  }\n  var self = this;\n\n  EventEmitter.call(this, options);\n\n  this._chain = [];\n  this.log = options.log;\n\n  var log = this.log;\n\n  function setupConnection(c) {\n    assert.ok(c);\n\n    if (c.type === 'unix') {\n      c.remoteAddress = self.server.path;\n      c.remotePort = c.fd;\n    } else if (c.socket) { // TLS\n      c.remoteAddress = c.socket.remoteAddress;\n      c.remotePort = c.socket.remotePort;\n    }\n\n\n    var rdn = new dn.RDN({cn: 'anonymous'});\n\n    c.ldap = {\n      id: c.remoteAddress + ':' + c.remotePort,\n      config: options,\n      _bindDN: new DN([rdn])\n    };\n    c.addListener('timeout', function () {\n      log.trace('%s timed out', c.ldap.id);\n      c.destroy();\n    });\n    c.addListener('end', function () {\n      log.trace('%s shutdown', c.ldap.id);\n    });\n    c.addListener('error', function (err) {\n      log.warn('%s unexpected connection error', c.ldap.id, err);\n      self.emit('clientError', err);\n      c.destroy();\n    });\n    c.addListener('close', function (had_err) {\n      log.trace('%s close; had_err=%j', c.ldap.id, had_err);\n      c.end();\n    });\n\n    c.ldap.__defineGetter__('bindDN', function () {\n      return c.ldap._bindDN;\n    });\n    c.ldap.__defineSetter__('bindDN', function (val) {\n      if (!(val instanceof DN))\n        throw new TypeError('DN required');\n\n      c.ldap._bindDN = val;\n      return val;\n    });\n    return c;\n  }\n\n  function newConnection(c) {\n    setupConnection(c);\n    log.trace('new connection from %s', c.ldap.id);\n\n    dtrace.fire('server-connection', function () {\n      return [c.remoteAddress];\n    });\n\n    c.parser = new Parser({\n      log: options.log\n    });\n    c.parser.on('message', function (req) {\n      req.connection = c;\n      req.logId = c.ldap.id + '::' + req.messageID;\n      req.startTime = new Date().getTime();\n\n      if (log.debug())\n        log.debug('%s: message received: req=%j', c.ldap.id, req.json);\n\n      var res = getResponse(req);\n      if (!res) {\n        log.warn('Unimplemented server method: %s', req.type);\n        c.destroy();\n        return false;\n      }\n\n      res.connection = c;\n      res.logId = req.logId;\n      res.requestDN = req.dn;\n\n      var chain = self._getHandlerChain(req, res);\n\n      var i = 0;\n      return function (err) {\n        function sendError(err) {\n          res.status = err.code || errors.LDAP_OPERATIONS_ERROR;\n          res.matchedDN = req.suffix ? req.suffix.toString() : '';\n          res.errorMessage = err.message || '';\n          return res.end();\n        }\n\n        function after() {\n          if (!self._postChain || !self._postChain.length)\n            return;\n\n          function next() {} // stub out next for the post chain\n\n          self._postChain.forEach(function (c) {\n            c.call(self, req, res, next);\n          });\n        }\n\n        if (err) {\n          log.trace('%s sending error: %s', req.logId, err.stack || err);\n          self.emit('clientError', err);\n          sendError(err);\n          return after();\n        }\n\n        try {\n          var next = arguments.callee;\n          if (chain.handlers[i])\n            return chain.handlers[i++].call(chain.backend, req, res, next);\n\n          if (req.protocolOp === Protocol.LDAP_REQ_BIND && res.status === 0)\n            c.ldap.bindDN = req.dn;\n\n          return after();\n        } catch (e) {\n          if (!e.stack)\n            e.stack = e.toString();\n          log.error('%s uncaught exception: %s', req.logId, e.stack);\n          return sendError(new errors.OperationsError(e.message));\n        }\n\n      }();\n    });\n\n    c.parser.on('error', function (err, message) {\n      log.error('Exception happened parsing for %s: %s',\n                c.ldap.id, err.stack);\n\n\n      if (!message)\n        return c.destroy();\n\n      var res = getResponse(message);\n      if (!res)\n        return c.destroy();\n\n      res.status = 0x02; // protocol error\n      res.errorMessage = err.toString();\n      return c.end(res.toBer());\n    });\n\n    c.on('data', function (data) {\n      if (log.trace())\n        log.trace('data on %s: %s', c.ldap.id, util.inspect(data));\n\n      try {\n        c.parser.write(data);\n      } catch (e) {\n        log.warn('Unable to parse message [c.on(\\'data\\')]: %s', e.stack);\n        c.end(new LDAPResult({\n          status: 0x02,\n          errorMessage: e.toString(),\n          connection: c\n        }).toBer());\n      }\n    });\n\n  } // end newConnection\n\n  this.routes = {};\n  if ((options.cert || options.certificate) && options.key) {\n    options.cert = options.cert || options.certificate;\n    this.server = tls.createServer(options, newConnection);\n  } else {\n    this.server = net.createServer(newConnection);\n  }\n  this.server.log = options.log;\n  this.server.ldap = {\n    config: options\n  };\n  this.server.on('close', function () {\n    self.emit('close');\n  });\n  this.server.on('error', function (err) {\n    self.emit('error', err);\n  });\n\n  this.__defineGetter__('maxConnections', function () {\n    return self.server.maxConnections;\n  });\n  this.__defineSetter__('maxConnections', function (val) {\n    self.server.maxConnections = val;\n  });\n  this.__defineGetter__('connections', function () {\n    return self.server.connections;\n  });\n  this.__defineGetter__('name', function () {\n    return 'LDAPServer';\n  });\n  this.__defineGetter__('url', function () {\n    var str;\n    if (this.server instanceof tls.Server) {\n      str = 'ldaps://';\n    } else {\n      str = 'ldap://';\n    }\n    str += self.host || 'localhost';\n    str += ':';\n    str += self.port || 389;\n    return str;\n  });\n}\nutil.inherits(Server, EventEmitter);\nmodule.exports = Server;\n\n\n/**\n * Adds a handler (chain) for the LDAP add method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.add = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_ADD, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP bind method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.bind = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_BIND, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP compare method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.compare = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_COMPARE, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP delete method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.del = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_DELETE, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP exop method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name OID to assign this handler chain to.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input.\n */\nServer.prototype.exop = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_EXTENSION, name, args, true);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP modify method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.modify = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_MODIFY, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP modifyDN method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.modifyDN = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_MODRDN, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP search method.\n *\n * Note that this is of the form f(name, [function]) where the second...N\n * arguments can all either be functions or arrays of functions.\n *\n * @param {String} name the DN to mount this handler chain at.\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.search = function (name) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return this._mount(Protocol.LDAP_REQ_SEARCH, name, args);\n};\n\n\n/**\n * Adds a handler (chain) for the LDAP unbind method.\n *\n * This method is different than the others and takes no mount point, as unbind\n * is a connection-wide operation, not constrianed to part of the DIT.\n *\n * @return {Server} this so you can chain calls.\n * @throws {TypeError} on bad input\n */\nServer.prototype.unbind = function () {\n  var args = Array.prototype.slice.call(arguments, 0);\n  return this._mount(Protocol.LDAP_REQ_UNBIND, 'unbind', args, true);\n};\n\n\nServer.prototype.use = function use() {\n  var args = Array.prototype.slice.call(arguments);\n  var chain = mergeFunctionArgs(args, 0, args.length);\n  var self = this;\n  chain.forEach(function (c) {\n    self._chain.push(c);\n  });\n};\n\n\nServer.prototype.after = function () {\n  if (!this._postChain)\n    this._postChain = [];\n\n  var self = this;\n  mergeFunctionArgs(arguments).forEach(function (h) {\n    self._postChain.push(h);\n  });\n};\n\n\n// All these just reexpose the requisite net.Server APIs\nServer.prototype.listen = function (port, host, callback) {\n  if (!port)\n    throw new TypeError('port (number) required');\n\n  if (typeof (host) === 'function') {\n    callback = host;\n    host = '0.0.0.0';\n  }\n  var self = this;\n\n  function _callback() {\n    if (typeof (port) === 'number') {\n      self.host = host;\n      self.port = port;\n    } else {\n      self.host = port;\n      self.port = self.server.fd;\n    }\n\n    if (typeof (callback) === 'function')\n      callback();\n  }\n\n  if (typeof (port) === 'number') {\n    return this.server.listen(port, host, _callback);\n  } else {\n    return this.server.listen(port, _callback);\n  }\n};\nServer.prototype.listenFD = function (fd) {\n  this.host = 'unix-domain-socket';\n  this.port = fd;\n  return this.server.listenFD(fd);\n};\nServer.prototype.close = function () {\n  return this.server.close();\n};\nServer.prototype.address = function () {\n  return this.server.address();\n};\n\n\nServer.prototype._getRoute = function (_dn, backend) {\n  assert.ok(dn);\n\n  if (!backend)\n    backend = this;\n\n  var name;\n  if (_dn instanceof dn.DN) {\n    name = _dn.toString();\n  } else {\n    name = _dn;\n  }\n\n  if (!this.routes[name]) {\n    this.routes[name] = {};\n    this.routes[name].backend = backend;\n    this.routes[name].dn = _dn;\n  }\n\n  return this.routes[name];\n};\n\n\nServer.prototype._getHandlerChain = function _getHandlerChain(req, res) {\n  assert.ok(req);\n\n  fireDTraceProbe(req, res);\n\n  // check anonymous bind\n  if (req.protocolOp === Protocol.LDAP_REQ_BIND &&\n      req.dn.toString() === '' &&\n      req.credentials === '') {\n    return {\n      backend: self,\n      handlers: [defaultNoOpHandler]\n    };\n  }\n\n  var op = '0x' + req.protocolOp.toString(16);\n\n  var self = this;\n  var routes = this.routes;\n  var keys = Object.keys(routes);\n  for (var i = 0; i < keys.length; i++) {\n    var r = keys[i];\n    var route = routes[r];\n\n    // Special cases are abandons, exops and unbinds, handle those first.\n    if (req.protocolOp === Protocol.LDAP_REQ_EXTENSION) {\n      if (r === req.requestName) {\n        return {\n          backend: routes.backend,\n          handlers: route[op] || [noExOpHandler]\n        };\n      }\n    } else if (req.protocolOp === Protocol.LDAP_REQ_UNBIND) {\n      return {\n        backend: routes['unbind'] ? routes['unbind'].backend : self,\n        handlers: function getUnbindChain() {\n          if (routes['unbind'] && routes['unbind'][op])\n            return routes['unbind'][op];\n\n          self.log.debug('%s unbind request %j', req.logId, req.json);\n          return [defaultNoOpHandler];\n        }\n      };\n    } else if (req.protocolOp === Protocol.LDAP_REQ_ABANDON) {\n      return {\n        backend: self,\n        handlers: [defaultNoOpHandler]\n      };\n    } else if (route[op]) {\n      // Otherwise, match via DN rules\n      assert.ok(req.dn);\n      assert.ok(route.dn);\n\n      if (route.dn.equals(req.dn) || route.dn.parentOf(req.dn)) {\n        // We should be good to go.\n        req.suffix = route.dn;\n        return {\n          backend: route.backend,\n          handlers: route[op] || [defaultHandler]\n        };\n      }\n    }\n  }\n\n  // We're here, so nothing matched.\n  return {\n    backend: self,\n    handlers: [(req.protocolOp !== Protocol.LDAP_REQ_EXTENSION ?\n                noSuffixHandler : noExOpHandler)]\n  };\n};\n\n\nServer.prototype._mount = function (op, name, argv, notDN) {\n  assert.ok(op);\n  assert.ok(name !== undefined);\n  assert.ok(argv);\n\n  if (typeof (name) !== 'string')\n    throw new TypeError('name (string) required');\n  if (!argv.length)\n    throw new Error('at least one handler required');\n\n  var backend = this;\n  var index = 0;\n\n  if (typeof (argv[0]) === 'object' && !Array.isArray(argv[0])) {\n    backend = argv[0];\n    index = 1;\n  }\n  var route = this._getRoute(notDN ? name : dn.parse(name), backend);\n\n  var chain = this._chain.slice();\n  argv.slice(index).forEach(function (a) {\n    chain.push(a);\n  });\n  route['0x' + op.toString(16)] = mergeFunctionArgs(chain);\n\n  return this;\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":21164}]],"length":21164}
