{"ts":1359577752757,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var events  = require('events')\n  , request = require('request')\n  , async   = require('async')\n  , _       = require('underscore')._\n  , OAuth2  = require('./oauth2')\n  , Query   = require('./query')\n  , SObject = require('./sobject')\n  ;\n\n/**\n * constructor\n */\nvar Connection = module.exports = function(options) {\n  this.initialize(options || {});\n};\n\n/**\n *\n */\nConnection.prototype = new events.EventEmitter();\n\nvar loginUrl = \"https://login.salesforce.com\"\n  , instanceUrl = \"https://{instance}.salesforce.com\"\n  , version  = \"23.0\"\n  ;\n\n/**\n * initialize\n */\nConnection.prototype.initialize = function(options) {\n  this.loginUrl  = options.loginUrl || this.loginUrl || loginUrl;\n  this.version   = options.version || this.version || version;\n  this.instanceUrl = options.instanceUrl || options.serverUrl || this.instanceUrl || \n                     instanceUrl.replace(\"{instance}\", options.instance || \"na1\");\n  this.urls = {\n    soap : {\n      login : [ this.loginUrl, \"services/Soap/u\", this.version ].join('/')\n    },\n    rest : {\n      base : [ this.instanceUrl, \"services/data\", \"v\" + this.version ].join('/')\n    },\n    streaming: {\n      base : [ this.instanceUrl, \"cometd\", this.version ].join('/')\n    }\n  };\n  if (options.clientId) {\n    this.oauth2 = new OAuth2({\n      authzServiceUrl : this.loginUrl + \"/services/oauth2/authorize\",\n      tokenServiceUrl : this.loginUrl + \"/services/oauth2/token\",\n      clientId : options.clientId,\n      clientSecret : options.clientSecret,\n      redirectUri : options.redirectUri\n    });\n  }\n  this.accessToken = options.sessionId || options.accessToken || this.accessToken;\n  this.refreshToken = options.refreshToken || this.refreshToken;\n  if (this.oauth2 && this.refreshToken) {\n    this.removeAllListeners('auth');\n    this.once('auth', _.bind(this._refresh, this));\n  }\n  this.maxRequest = options.maxRequest || this.maxRequest || 10;\n};\n\n\n/**\n * Sending request to API endpoint\n * @private\n */\nConnection.prototype._request = function(params, callback, noContentResponse) {\n  var self = this;\n  var onResume = function() {\n    self._request(params, callback, noContentResponse); \n  };\n  if (self.suspended) {\n    self.once('resume', onResume);\n    return;\n  }\n  params.headers = params.headers || {};\n  if (this.accessToken) {\n    params.headers.Authorization = \"OAuth \" + this.accessToken;\n  }\n  self.emit('request', params.method, params.url, params);\n  request(params, function(err, response) {\n    if (err) {\n      callback(err);\n    } else {\n      self.emit('response', response.statusCode, response.body, response);\n      // if authorization required and auth handler is available\n      if (response.statusCode === 401 && self.listeners('auth').length >= 0) {\n        self.suspended = true;\n        self.once('resume', onResume);\n        self.emit('auth');\n        return;\n      }\n      if (response.statusCode >= 400) {\n        var errors;\n        try {\n          errors = JSON.parse(response.body);\n        } catch(e) {\n          errors = [{ message : response.body }];\n        }\n        callback(errors[0]);\n      } else if (response.statusCode === 204) {\n        callback(null, noContentResponse);\n      } else {\n        var res;\n        try {\n          res = JSON.parse(response.body);\n        } catch(e2) {\n          err = e2;\n        }\n        if (response.statusCode === 300) { // Multiple Choices\n          err = { message : 'Multiple records found' };\n        }\n        callback(err, res);\n      }\n    }\n  });\n};\n\n/**\n * Refresh access token\n * @private\n */\nConnection.prototype._refresh = function() {\n  var self = this;\n  this.oauth2.refreshToken(this.refreshToken, function(err, res) {\n    if (!err) {\n      self.initialize({\n        instanceUrl : res.instance_url,\n        accessToken : res.access_token\n      });\n      self.once('auth', _.bind(self._refresh, self));\n    }\n    self.suspended = false;\n    self.emit('resume');\n  });\n};\n\n\n/**\n * query\n */\nConnection.prototype.query = function(soql, callback) {\n  var query = new Query(this, soql);\n  if (callback) {\n    query.run(callback);\n  }\n  return query;\n};\n\n/**\n * queryMore\n */\nConnection.prototype.queryMore = function(locator, callback) {\n  var query = new Query(this, null, locator);\n  if (callback) {\n    query.run(callback);\n  }\n  return query;\n};\n\n\n/**\n * retrieve\n */\nConnection.prototype.retrieve = function(type, ids, callback) {\n  var self = this;\n  var isArray = _.isArray(ids);\n  ids = isArray ? ids : [ ids ];\n  if (ids.length > self.maxRequest) {\n    callback({ message : \"Exceeded max limit of concurrent call\" });\n    return;\n  }\n  async.parallel(_.map(ids, function(id) {\n    return function(cb) {\n      var url = [ self.urls.rest.base, \"sobjects\", type, id ].join('/');\n      self._request({\n        method : 'GET',\n        url : url\n      }, cb);\n    };\n  }), function(err, results) {\n    callback(err, !isArray && _.isArray(results) ? results[0] : results);\n  });\n};\n\n\n/**\n * create\n */\nConnection.prototype.create = function(type, records, callback) {\n  if (arguments.length === 2) {\n    type = null;\n    records = type;\n    callback = records;\n  }\n  var self = this;\n  var isArray = _.isArray(records);\n  records = isArray ? records : [ records ];\n  if (records.length > self.maxRequest) {\n    callback({ message : \"Exceeded max limit of concurrent call\" });\n    return;\n  }\n  async.parallel(_.map(records, function(record) {\n    return function(cb) {\n      var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n      if (!sobjectType) {\n        cb({ message : 'No SObject Type defined in record' });\n        return;\n      }\n      record = _.clone(record);\n      delete record.Id;\n      delete record.type;\n      delete record.attributes;\n\n      var url = [ self.urls.rest.base, \"sobjects\", sobjectType ].join('/');\n      self._request({\n        method : 'POST',\n        url : url,\n        body : JSON.stringify(record),\n        headers : {\n          \"Content-Type\" : \"application/json\"\n        }\n      }, cb);\n    };\n  }), function(err, results) {\n    callback(err, !isArray && _.isArray(results) ? results[0] : results);\n  });\n};\n\n/**\n * update\n */\nConnection.prototype.update = function(type, records, callback) {\n  if (arguments.length === 2) {\n    type = null;\n    records = type;\n    callback = records;\n  }\n  var self = this;\n  var isArray = _.isArray(records);\n  records = isArray ? records : [ records ];\n  if (records.length > self.maxRequest) {\n    callback({ message : \"Exceeded max limit of concurrent call\" });\n    return;\n  }\n  async.parallel(_.map(records, function(record) {\n    return function(cb) {\n      var id = record.Id;\n      if (!id) {\n        cb({ message : 'Record id is not found in record.' });\n        return;\n      }\n      var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n      if (!sobjectType) {\n        cb({ message : 'No SObject Type defined in record' });\n        return;\n      }\n      record = _.clone(record);\n      delete record.Id;\n      delete record.type;\n      delete record.attributes;\n\n      var url = [ self.urls.rest.base, \"sobjects\", sobjectType, id ].join('/');\n      self._request({\n        method : 'PATCH',\n        url : url,\n        body : JSON.stringify(record),\n        headers : {\n          \"Content-Type\" : \"application/json\"\n        }\n      }, cb, { id : id, success : true, errors : [] });\n    };\n  }), function(err, results) {\n    callback(err, !isArray && _.isArray(results) ? results[0] : results);\n  });\n};\n\n/**\n * upsert\n */\nConnection.prototype.upsert = function(type, records, extIdField, callback) {\n  // You can omit \"type\" argument, when the record includes type information.\n  if (arguments.length === 3) {\n    type = null;\n    records = type;\n    extIdField = records;\n    callback = extIdField;\n  }\n  var self = this;\n  var isArray = _.isArray(records);\n  records = isArray ? records : [ records ];\n  if (records.length > self.maxRequest) {\n    callback({ message : \"Exceeded max limit of concurrent call\" });\n    return;\n  }\n  async.parallel(_.map(records, function(record) {\n    return function(cb) {\n      var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n      var extId = record[extIdField];\n      if (!extId) {\n        cb({ message : 'External ID is not defined in the record' });\n        return;\n      }\n      record = _.clone(record);\n      delete record[extIdField];\n      delete record.type;\n      delete record.attributes;\n\n      var url = [ self.urls.rest.base, \"sobjects\", sobjectType, extIdField, extId ].join('/');\n      self._request({\n        method : 'PATCH',\n        url : url,\n        body : JSON.stringify(record),\n        headers : {\n          \"Content-Type\" : \"application/json\"\n        }\n      }, cb, { success : true, errors : [] });\n    };\n  }), function(err, results) {\n    callback(err, !isArray && _.isArray(results) ? results[0] : results);\n  });\n};\n\n\n\n/**\n * destroy\n */\nConnection.prototype.del =\nConnection.prototype.destroy = function(type, ids, callback) {\n  var self = this;\n  var isArray = _.isArray(ids);\n  ids = isArray ? ids : [ ids ];\n  if (ids.length > self.maxRequest) {\n    callback({ message : \"Exceeded max limit of concurrent call\" });\n    return;\n  }\n  async.parallel(_.map(ids, function(id) {\n    return function(cb) {\n      var url = [ self.urls.rest.base, \"sobjects\", type, id ].join('/');\n      self._request({\n        method : 'DELETE',\n        url : url\n      }, cb, { id : id, success : true, errors : [] });\n    };\n  }), function(err, results) {\n    callback(err, !isArray && _.isArray(results) ? results[0] : results);\n  });\n};\n\n\n/**\n * describe\n */\nConnection.prototype.describe = function(type, callback) {\n  var url = [ this.urls.rest.base, \"sobjects\", type, \"describe\" ].join('/');\n  this._request({\n    method : 'GET',\n    url : url\n  }, callback);\n};\n\n/**\n * describeGlobal\n */\nConnection.prototype.describeGlobal = function(callback) {\n  var url = this.urls.rest.base + \"/sobjects\";\n  this._request({\n    method : 'GET',\n    url : url\n  }, callback);\n};\n\n\n/**\n * sobject\n */\nConnection.prototype.sobject = function(type) {\n  this._sobjects = this._sobjects || {};\n  var sobject = this._sobjects[type] = \n    this._sobjects[type] || new SObject(type, this);\n  return sobject;\n};\n\n\n/**\n * Authorize (using oauth2 web server flow)\n */\nConnection.prototype.authorize = function(code, callback) {\n  var self = this;\n  this.oauth2.requestToken(code, function(err, res) {\n    if (err) {\n      callback(err);\n      return;\n    }\n    self.initialize({\n      instanceUrl : res.instance_url,\n      accessToken : res.access_token,\n      refreshToken : res.refresh_token\n    });\n    callback(null);\n  });\n};\n\n\n/**\n * login (using oauth2 username & password flow)\n */\nConnection.prototype.login = function(username, password, callback) {\n  if (this.oauth2) {\n    this.loginByOAuth2(username, password, callback);\n  } else {\n    this.loginBySoap(username, password, callback);\n  }\n};\n\n\n/**\n * Login by OAuth2 username & password flow\n */\nConnection.prototype.loginByOAuth2 = function(username, password, callback) {\n  var self = this;\n  this.oauth2.authenticate(username, password, function(err, res) {\n    if (err) {\n      callback(err);\n      return;\n    }\n    self.initialize({\n      instanceUrl : res.instance_url,\n      accessToken : res.access_token\n    });\n    callback(null);\n  });\n};\n\n/**\n * Login by SOAP web service API\n */\nConnection.prototype.loginBySoap = function(username, password, callback) {\n  function esc(str) {\n    return str && String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;')\n                             .replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n  }\n  var self = this;\n  var body = [\n    '<se:Envelope xmlns:se=\"http://schemas.xmlsoap.org/soap/envelope/\">',\n    '<se:Header xmlns:sfns=\"urn:partner.soap.sforce.com\"/>',\n    '<se:Body>',\n    '<login xmlns=\"urn:partner.soap.sforce.com\" xmlns:ns1=\"sobject.partner.soap.sforce.com\">',\n    '<username>' + esc(username) + '</username>',\n    '<password>' + esc(password) + '</password>',\n    '</login>',\n    '</se:Body>',\n    '</se:Envelope>'\n  ].join('');\n\n  request({\n    method : 'POST',\n    url : this.urls.soap.login,\n    body : body,\n    headers : {\n      \"Content-Type\" : \"text/xml\",\n      \"SOAPAction\" : '\"\"'\n    }\n  }, function(err, response) {\n    if (err) {\n      callback(err);\n      return;\n    } \n    if (response.statusCode >= 400) {\n      callback({ message : response.body });\n      return;\n    }\n    var m = response.body.match(/<serverUrl>([^<]+)<\\/serverUrl>/);\n    var serverUrl = m && m[1];\n    m = response.body.match(/<sessionId>([^<]+)<\\/sessionId>/);\n    var sessionId = m && m[1];\n    self.initialize({ \n      serverUrl: serverUrl.split('/').slice(0, 3).join('/'), \n      sessionId: sessionId\n    });\n    callback(null);\n  });\n};\n\n\n\n"]],"start1":0,"start2":0,"length1":0,"length2":12838}]],"length":12838}
