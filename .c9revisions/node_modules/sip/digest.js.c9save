{"ts":1358175826334,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var crypto = require('crypto');\nvar util = require('util');\n\nfunction unq(a) {\n  if(a && a[0] === '\"' && a[a.length-1] === '\"')\n    return a.substr(1, a.length - 2);\n  return a;\n}\n\nfunction q(a) {\n  if(a && a[0] !== '\"')\n    return ['\"', a, '\"'].join('');\n  return a;\n}\n\nfunction lowercase(a) {\n  if(typeof a === 'string')\n    return a.toLowerCase();\n  return a;\n}\n\nfunction kd() {\n  var hash = crypto.createHash('md5');\n\n  var a = Array.prototype.join.call(arguments, ':');\n  hash.update(a);\n\n  return hash.digest('hex');\n}\nexports.kd = kd;\n\nfunction rbytes() {\n  return kd(Math.random().toString(), Math.random().toString());\n}\n\nfunction calculateUserRealmPasswordHash(user, realm, password) {\n  return kd(unq(user), unq(realm), unq(password));\n}\nexports.calculateUserRealmPasswordHash = calculateUserRealmPasswordHash;\n\nfunction calculateHA1(ctx) {\n  var userhash = ctx.userhash || calculateUserRealmPasswordHash(ctx.user, ctx.realm, ctx.password);\n  if(ctx.algorithm === 'md5-sess') return kd(userhash, ctx.nonce, ctx.cnonce);\n\n  return userhash; \n}\nexports.calculateHA1 = calculateHA1;\n\nfunction calculateDigest(ctx) {\n  switch(ctx.qop) {\n  case 'auth-int':\n    return kd(ctx.ha1, ctx.nonce, ctx.nc, ctx.cnonce, ctx.qop, kd(ctx.method, ctx.uri, kd(ctx.entity)));\n  case 'auth':\n    return kd(ctx.ha1, ctx.nonce, ctx.nc, ctx.cnonce, ctx.qop, kd(ctx.method, ctx.uri));\n  }\n\n  return kd(ctx.ha1, ctx.nonce, kd(ctx.method, ctx.uri));\n}\nexports.calculateDigest = calculateDigest;\n\nvar nonceSalt = rbytes();\nfunction generateNonce(tag, timestamp) {\n  var ts = (timestamp || new Date()).toISOString();\n  return new Buffer([ts, kd(ts, tag, nonceSalt)].join(';'), 'ascii').toString('base64');\n}\nexports.generateNonce = generateNonce;\n\nfunction extractNonceTimestamp(nonce, tag) {\n  var v = new Buffer(nonce, 'base64').toString('ascii').split(';');\n  if(v.length != 2)\n    return;\n\n  var ts = new Date(v[0]);\n\n  return generateNonce(tag, ts) === nonce && ts;\n}\nexports.extractNonceTimestamp = extractNonceTimestamp;\n\nfunction numberTo8Hex(n) {\n  n = n.toString(16);\n  return '00000000'.substr(n.length) + n;\n}\n\nfunction findDigestRealm(headers, realm) {\n  if(!realm) return headers && headers[0];\n  return headers && headers.filter(function(x) { return x.scheme === 'Digest' && unq(x.realm) === realm; })[0];\n}\n\nfunction selectQop(challenge, preference) {\n  if(!challenge)\n    return;\n\n  challenge = unq(challenge).split(',');\n  if(!preference)\n    return challenge[0];\n\n  if(typeof(preference) === 'string') \n    preference = preference.split(',');\n\n  for(var i = 0; i !== preference.length; ++i)\n    for(var j = 0; j !== challenge.length; ++j)\n      if(challenge[j] === preference[i])\n        return challenge[j];\n\n  throw new Error('failed to negotiate protection quality');\n}\n\nexports.challenge = function(ctx, rs) {\n  ctx.proxy = rs.status === 407;\n\n  ctx.nonce = ctx.cnonce || rbytes();\n  ctx.nc = 0;\n  ctx.qop = ctx.qop || 'auth,auth-int';\n  ctx.algorithm = ctx.algorithm || 'md5';\n\n\n  var hname = ctx.proxy ? 'proxy-authenticate' : 'www-authenticate';\n  (rs.headers[hname] || (rs.headers[hname]=[])).push(\n    {\n      scheme: 'Digest',\n      realm: q(ctx.realm),\n      qop: q(ctx.qop),\n      algorithm: q(ctx.algoritm),\n      nonce: q(ctx.nonce),\n      opaque: q(ctx.opaque)\n    }\n  );\n\n  return rs;\n}\n\nexports.authenticateRequest = function(ctx, rq, creds) {\n  var response = findDigestRealm(rq.headers[ctx.proxy ? 'proxy-authorization': 'authorization'], ctx.realm);\n\n  if(!response) return false;\n\n  var cnonce = unq(response.cnonce);\n  var uri = unq(response.uri);\n  var qop = unq(lowercase(response.qop));\n\n  ctx.nc = (ctx.nc || 0) +1;\n  \n  if(!ctx.ha1) {\n    ctx.userhash = creds.hash || calculateUserRealmPasswordHash(creds.user, ctx.realm, creds.password);\n    ctx.ha1 = ctx.userhash;\n    if(ctx.algoritm === 'md5-sess')\n      ctx.ha1 = kd(ctx.userhash, ctx.nonce, cnonce);\n  }\n  \n  var digest = calculateDigest({ha1:ctx.ha1, method:rq.method, nonce:ctx.nonce, nc:numberTo8Hex(ctx.nc), cnonce:cnonce, qop:qop, uri:uri, entity:rq.content});\n  if(digest === unq(response.response)) {\n    ctx.cnonce = cnonce;\n    ctx.uri = uri;\n    ctx.qop = qop;\n\n    return true;\n  } \n\n  return false;\n}\n\nexports.signResponse = function(ctx, rs) {\n  var nc = numberTo8Hex(ctx.nc);\n  rs.headers['authentication-info'] = {\n    qop: ctx.qop,\n    cnonce: q(ctx.cnonce),\n    nc: nc,\n    rspauth: q(calculateDigest({ha1:ctx.ha1, method:'', nonce:ctx.nonce, nc:nc, cnonce:ctx.cnonce, qop:ctx.qop, uri:ctx.uri, entity:rs.content}))\n  };\n  return rs;\n}\n\nfunction initClientContext(ctx, rs, creds) {\n  var challenge;\n\n  if(rs.status === 407) {\n    ctx.proxy = true;\n    challenge = findDigestRealm(rs.headers['proxy-authenticate'], creds.realm);\n  }\n  else\n    challenge = findDigestRealm(rs.headers['www-authenticate'], creds.realm);\n  \n  if(ctx.nonce !== unq(challenge.nonce)) {\n    ctx.nonce = unq(challenge.nonce);\n\n    ctx.algorithm = unq(lowercase(challenge.algorithm));\n    ctx.qop = selectQop(lowercase(challenge.qop), ctx.qop);\n \n    if(ctx.qop) {\n      ctx.nc = 0;\n      ctx.cnonce = rbytes();\n    }\n\n    ctx.realm = unq(challenge.realm);\n    ctx.user = creds.user;\n    ctx.userhash = creds.hash || calculateUserRealmPasswordHash(creds.user, ctx.realm, creds.password);\n    ctx.ha1 = ctx.userhash;\n\n    if(ctx.algorithm === 'md5-sess')\n      ctx.ha1 = kd(ctx.ha1, ctx.nonce, ctx.cnonce);\n\n    ctx.domain = unq(challenge.domain);\n }\n\n  ctx.opaque = unq(challenge.opaque);\n}\n\nexports.signRequest = function (ctx, rq, rs, creds) {\n  if(rs)\n    initClientContext(ctx, rs, creds);\n\n  var nc = ctx.nc !== undefined ? numberTo8Hex(++ctx.nc) : undefined;\n\n  ctx.uri = rq.uri;\n  \n  var signature = {\n    scheme: 'Digest',\n    realm: q(ctx.realm),\n    username: q(ctx.user),\n    nonce: q(ctx.nonce), \n    uri: q(rq.uri),\n    nc: nc,\n    algorithm: q(ctx.algorithm),\n    cnonce: q(ctx.cnonce),\n    qop: ctx.qop,\n    opaque: q(ctx.opaque),\n    response: q(calculateDigest({ha1:ctx.ha1, method:rq.method, nonce:ctx.nonce, nc:nc, cnonce:ctx.cnonce, qop:ctx.qop, uri:ctx.uri, entity:rq.content}))    \n  };\n\n  var hname = ctx.proxy ? 'proxy-authorization' : 'authorization'; \n \n  rq.headers[hname] = (rq.headers[hname] || []).filter(function(x) { return unq(x.realm) !== ctx.realm; });\n  rq.headers[hname].push(signature);\n\n  return rq;\n}\n\nexports.authenticateResponse = function(ctx, rs) {\n  var signature = rs.headers[ctx.proxy ? 'proxy-authentication-info' : 'authentication-info'];\n\n  if(!signature) return undefined;\n\n  var digest=calculateDigest({ha1:ctx.ha1, method:'', nonce:ctx.nonce, nc:numberTo8Hex(ctx.nc), cnonce:ctx.cnonce, qop:ctx.qop, uri:ctx.uri, enity:rs.content});\n  if(digest === unq(signature.rspauth)) {\n    var nextnonce = unq(signature.nextnonce);\n    if(nextnonce && nextnonce !== ctx.nonce) {\n      ctx.nonce = nextnonce;\n      ctx.nc = 0;\n\n      if(ctx.algorithm === 'md5-sess') \n        ctx.ha1 = kd(ctx.userhash, ctx.nonce, ctx.cnonce);\n    }\n\n    return true;\n  }\n \n  return false;\n}\n\n\n"]],"start1":0,"start2":0,"length1":0,"length2":6994}]],"length":6994}
