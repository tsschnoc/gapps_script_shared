{"ts":1340217972005,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"SIP.js API\n==========\n\nsip.js is a simple SIP protocol implementation.\n\nIt features:\n\n* SIP Message Parser\n* UDP and TCP based transport\n* Transactions\n* Digest Authentication\n\nExample\n--------------------\n\nRedirecting all SIP requests to backup.somewhere.net\n\n    var sip = require('sip');\n  \n    sip.start({}, function(request) {\n      var response = sip.makeResponse(request, 302, 'Moved Temporarily');\n\n      var uri = sip.parseUri(request.uri);\n      uri.host = 'backup.somewhere.net'; \n      response.headers.contact = [{uri: uri}];\n    \n      sip.send(response);\n    });\n\nMessages\n---------\n\nParsed SIP messages are javascript objects. Message\n\n    INVITE sip:service@172.16.2.2:5060 SIP/2.0\n    Via: SIP/2.0/UDP 127.0.1.1:5060;branch=z9hG4bK-1075-1-0\n    From: sipp <sip:sipp@127.0.1.1:5060>;tag=1075SIPpTag001\n    To: sut <sip:service@172.16.2.2:5060>\n    Call-ID: 1-1075@127.0.1.1\n    CSeq: 1 INVITE\n    Contact: sip:sipp@127.0.1.1:5060\n    Max-Forwards: 70\n    Subject: Performance Test\n    Content-Type: application/sdp\n    Content-Length:   127\n\n    v=0\n    o=user1 53655765 2353687637 IN IP4 127.0.1.1\n    s=-\n    c=IN IP4 127.0.1.1\n    t=0 0\n    m=audio 6000 RTP/AVP 0\n    a=rtpmap:0 PCMU/8000\n    \nis parsed to following object\n\n    { method: 'INVITE'\n    , uri: 'sip:service@172.16.2.2:5060'\n    , version: '2.0'\n    , headers: \n       { via: \n          [ { version: '2.0'\n            , protocol: 'UDP'\n            , host: '127.0.1.1'\n            , port: 5060\n            , params: { branch: 'z9hG4bK-1075-1-0' }\n            }\n          ]\n       , from: \n          { name: 'sipp'\n          , uri: 'sip:sipp@127.0.1.1:5060'\n          , params: { tag: '1075SIPpTag001' }\n          }\n       , to: \n          { name: 'sut'\n          , uri: 'sip:service@172.16.2.2:5060'\n          , params: {}\n          }\n       , 'call-id': '1-1075@127.0.1.1'\n       , cseq: { seq: 1, method: 'INVITE' }\n       , contact: \n          [ { name: undefined\n            , uri: 'sip:sipp@127.0.1.1:5060'\n            , params: {}\n            }\n          ]\n       , 'max-forwards': '70'\n       , subject: 'Performance Test'\n       , 'content-type': 'application/sdp'\n       , 'content-length': 127\n       }\n    , content: 'v=0\\r\\no=user1 53655765 2353687637 IN IP4 127.0.1.1\\r\\ns=-\\r\\nc=IN IP4 127.0.1.1\\r\\nt=0 0\\r\\nm=audio 6000 RTP/AVP 0\\r\\na=rtpmap:0 PCMU/8000'\n    }    \n\nSIP requests have `method` and `uri` properties and responses have `status` and `reason` instead.\n\n## High Level API\n\n### sip.start(options, onRequest)\n\nStarts SIP protocol. \n\n`options` - an object optionally containing following properties. \n\n* `port` - port to be used by trasport. 5060 by default.\n* `address` - interface address to be listen on. By default sip.js listens on all interfaces.\n* `udp` - enables UDP transport. Enabled by default.\n* `tcp` - enables TCP transport. Enabled by default.\n\n`onRequest` - callback to be called on new request arrival. It is expected to be a function of two arguments\n`function (request, remote) {}`. First argument `request` is a received request. Second argument `remote` is an object containing\nprotocol, address and port of a remote socket used to send the request. For example\n`{ protocol: 'TCP', address: '192.168.135.11', port: 50231 }`\n\n### sip.stop\n\nStops SIP protocol.\n\n### sip.send(message[, callback])\n\nSends SIP message transactionally.\n\nIf `message` is an non-`'ACK'` request then client transaction is created. Non-`'ACK'` requests are passed directy to transport layer.\n\nIf `message` is a response then server transaction is looked up and passed the message. There is no special handling of success\nresponses to `'INVITE'` requests. It is not necessary because in sip.js `'INVITE'` server transactions are not destroyed on 2xx responses \nbut kept around for another 32 seconds (as per RFC 6026). Applications still need to resend success `'INVITE'` responses. \n\n## Helper Functions\n\n### sip.makeResponse(request, status[, reason])\n\nreturns SIP response object for `request` with `status` and `reason` fields set.\n\n### sip.parseUri(uri)\n\nparses SIP uri.\n\n### sip.stringifyUri(uri)\n\nstringifies SIP uri.\n\n### sip.parse(message)\n\nparses SIP message.\n\n### sip.stringify(message)\n\nstringfies SIP message.\n\n### sip.copyMessage(message[, deep])\n\ncopies SIP message. If parameter `deep` is false or omitted it copies only `method`, `uri`, `status`, `reason`, `headers`, `content` \nfields of root object and `headers.via` array. If deep is true it performs full recursive copy of message object.\n\n## Digest Authentication\n\nsip.js implements digest authentication as described in RFC 2617. Module can be accessed by calling `require('sip/digest');`\n\n### Server-side API\n\n#### digest.challenge(session, response)\n\ninserts digest challenge ('WWW-Authethicate' or 'Proxy-Authenticate' headers) into response and returns it. `session` parameter\nis a javascript object containing at least `realm` property. On return it will contain session parameters (nonce, nonce-count etc)\nand should be passed to subsequent `authenticateRequest` calls. It is a plain object containing only numbers and strings and can be\n'jsoned' and saved to database if required.\n\n#### digest.authenticateRequest(session, request[, credentials])\n\nreturns `true` if request is signed using supplied challenge and credentials. `credentials` required only on first call to generate `ha1` value \nwhich is cached in `session` object. `credentials` is an object containing following properties:\n\n* `user` - user's account name\n* `realm` - protection realm name. optinal, should match realm passed in corresponding `challenge` call.\n* `password` - user's password. optional if `hash` property is present.\n* `hash` - hash of user's name, password and protection realm. Optional if `password` is present. Can be obtained by calling \n  `digest.calculateUserRealmPasswordHash` and used if you don't want to store passwords as clear text.\n\n#### digest.signResponse(session, response)\n\ninserts 'Authentication-Info' header into response. Used for mutual client-server authentication.\n\n### Client-side API\n\n### digest.signRequest(session, request[, response, credentials])\n\ninserts 'Authorization' or 'Proxy-Authorization' headers into request and returns it. To initialize the session after server challenge reception,\nsupply `response` (must be 401 or 407 response containing server challenge) and `credentials`. `credentials` parameter described in \n`digest.authenticateRequest` description.\n\n### digest.authenticateResponse(session, response)\n\nchecks server signature in 'Authentication-Info' parameter. Returns `true` if signature is valid, `false` if invalid and `undefined` if no 'Authentication-Info'\nheader present or it lacks `rspauth` parameter. If server supplied `nextnonce` parameter reinitializes `session`. \n\n### Low level functions\n\n#### digest.calculateDigest(arguments)\n\ncalculates digest as described in RFC 2617. `arguments` is an object with following properties\n\n* `ha1`\n* `nonce`\n* `nc`\n* `cnonce`\n* `qop`\n* `method`\n* `uri`\n* `entity`\n\n#### digest.calculateHA1(arguments)\n\ncalculates H(A1) value as described if RFC 2617. `arguments` is an object with followin properties\n\n* `userhash` - hash of user's name, realm and password. Optional if `user`, `realm` and `password` properties are present\n* `user` - user's name. Optional if `userhash` is present.\n* `realm` - realm name. Optional if `userhash` is present.\n* `password` - user's password in realm. Optional if `userhash` is present.\n* `algorithm` - authentication algorithm. Optional, by default used value `md5`.\n* `nonce` - server's nonce parameter. Optional if `algorithm` is _not_ equal to `md5-sess`\n* `cnonce` - client's nonce. Optional if `algorithm` is _not_ equal to `md5-sess`\n\n#### digest.calculateUserRealmPasswordHash(user, realm, password)\n\ncalculates hash of 'user:realm:password'\n\n## Proxy Module\n\nsip.js includes proxy module to simplify proxy server development. It can be accessed via `require('sip/proxy');`\nUsage example:\n\n    var sip = require('sip');\n    var proxy = require('sip/proxy');\n    var db = require('userdb');\n\n    proxy.start({}, function(rq) {\n      var user = sip.parseUri(rq.uri).user;\n\n      if(user) {\n        rq.uri = db.getContact(user);\n\n        proxy.send(rq);\n      }\n      else\n        proxy.send(sip.makeResponse(rq, 404, 'Not Found')); \n    });\n\n\n### proxy.start(options, onRequest)\n\nStarts proxy and SIP stack. Parameters are analogous to `sip.start`\n\n### proxy.stop\n\nstops proxy core and sip stack.\n\n### proxy.send(msg[, callback])\n\nUse this function to respond to or to make new requests in context of incoming requests. Proxy core will\nautomatically handle cancelling of incoming request and issue `CANCEL` requests for outstanding requests on your\nbehalf. Outgoing requests are bound to context through their top via header.\nIf you are sending a request and omit `callback` parameter, default calback will be used:\n\n    function defaultProxyCallback(rs) {\n      // stripping top Via\n      rs.headers.via.shift();\n\n      // sending response to original incoming request\n      proxy.send(rs);\n    } \n\n\n\n"]],"start1":0,"start2":0,"length1":0,"length2":9102}]],"length":9102}
