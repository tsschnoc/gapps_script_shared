{"ts":1340218572155,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var utils = require('sys');\nvar net = require('net');\nvar dns = require('dns');\nvar assert = require('assert');\nvar dgram = require('dgram');\n\nvar v05 = !(process.version < 'v0.5.0');\n\n//Various utility stuff\n\nif(!v05) {\n//node.js 'dgram' module do not allow proper ICMP errors handling\nvar udp = (function() {\n  var events = require('events');\n\n  try {\n    var IOWatcher    = process.binding('io_watcher').IOWatcher;\n  } \n  catch(e) {\n    var IOWatcher    = process.IOWatcher;\n  }\n  var binding      = process.binding('net');\n  var socket       = binding.socket;\n  var recvfrom     = binding.recvfrom;\n  var close        = binding.close;\n\n  var pool = null;\n\n  function getPool() {\n    var minPoolAvail = 1024 * 8;\n\n    var poolSize = 1024 * 64;\n\n    if (pool === null || (pool.used + minPoolAvail  > pool.length)) {\n      pool = new Buffer(poolSize);\n      pool.used = 0;\n    }\n\n    return pool;\n  }\n\n  function Socket(listener) {\n    events.EventEmitter.call(this);\n    var self = this;\n    self.fd = socket('udp4');\n\n    if(typeof listener === 'function')\n      self.on('message', listener);\n\n    self.watcher = new IOWatcher();\n    self.watcher.host = self;\n    self.watcher.callback = function() {\n      try {\n        while(self.fd) {\n          var p = getPool();\n          var rinfo = recvfrom(self.fd, p, p.used, p.length-p.used, 0);\n       \n          if(!rinfo) return;\n\n          self.emit('message', p.slice(p.used, p.used + rinfo.size), rinfo);\n\n          p.used += rinfo.size;\n        }\n      }\n      catch(e) {\n        self.emit('error', e);\n      } \n    };\n\n    self.watcher.set(this.fd, true, false); \n    self.watcher.start(); \n  }\n\n  utils.inherits(Socket, events.EventEmitter); \n\n  Socket.prototype.bind = function(port, address) {\n    binding.bind(this.fd, port, address);\n    this.emit('listening');\n  }\n\n  Socket.prototype.connect = function(port, address) {\n    binding.connect(this.fd, port, address);\n  }\n\n  Socket.prototype.address = function () {\n    return binding.getsockname(this.fd);\n  };\n\n  Socket.prototype.send = function(buffer, offset, length, callback) {\n    if (typeof offset !== \"number\" || typeof length !== \"number\") {\n      throw new Error(\"send takes offset and length as args 2 and 3\");\n    }\n\n    try {\n      var bytes = binding.sendMsg(this.fd, buffer, offset, length);\n    }\n    catch(err) {\n      if (callback) {\n        callback(err);\n      }\n      return;\n    }\n \n    if(callback) {\n      callback(null, bytes);\n    }\n  };\n\n  Socket.prototype.close = function () {\n    if (!this.fd) throw new Error('Not running');\n\n    this.watcher.stop();\n\n    close(this.fd);\n    this.fd = null;\n\n    this.emit(\"close\");\n  };\n\n  return { createSocket: function(listener) { return new Socket(listener); } };\n})();\n}\n\nfunction debug(e) {\n  if(e.stack) {\n    utils.debug(e + '\\n' + e.stack);\n  }\n  else\n    utils.debug(utils.inspect(e));\n}\n\n// Actual stack code begins here\n\nfunction parseResponse(rs, m) {\n  var r = rs.match(/^SIP\\/(\\d+\\.\\d+)\\s+(\\d+)\\s*(.*)\\s*$/);\n\n  if(r) {\n    m.version = r[1];\n    m.status = +r[2];\n    m.reason = r[3];\n\n    return m;\n  }  \n}\n\nfunction parseRequest(rq, m) {\n  var r = rq.match(/^([\\w\\-.!%*_+`'~]+)\\s([^\\s]+)\\sSIP\\s*\\/\\s*(\\d+\\.\\d+)/);\n\n  if(r) {\n    m.method = unescape(r[1]);\n    m.uri = r[2];\n    m.version = r[3];\n\n    return m;\n  }\n}\n\nfunction applyRegex(regex, data) {\n  regex.lastIndex = data.i;\n  var r = regex.exec(data.s);\n\n  if(r && (r.index === data.i)) {\n    data.i = regex.lastIndex;\n    return r;\n  }\n}\n\nfunction parseParams(data, hdr) {\n  hdr.params = hdr.params || {};\n\n  var re = /\\s*;\\s*([\\w\\-.!%*_+`'~]+)(?:\\s*=\\s*([\\w\\-.!%*_+`'~]+|\"[^\"\\\\]*(\\\\.[^\"\\\\]*)*\"))?/g; \n  \n  for(var r = applyRegex(re, data); r; r = applyRegex(re, data)) {\n    hdr.params[r[1].toLowerCase()] = r[2];\n  }\n\n  return hdr;\n}\n\nfunction parseMultiHeader(parser, d, h) {\n  h = h || [];\n\n  var re = /\\s*,\\s*/g;\n  do {\n    h.push(parser(d));\n  } while(d.i < d.s.length && applyRegex(re, d));\n\n  return h;\n}\n\nfunction parseGenericHeader(d, h) {\n  return h ? h + ',' + d.s : d.s;\n}\n\nfunction parseAOR(data) {\n  var r = applyRegex(/((?:[\\w\\-.!%*_+`'~]+)(?:\\s+[\\w\\-.!%*_+`'~]+)*|\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")?\\s*\\<\\s*([^>]*)\\s*\\>|((?:[^\\s@\"<]@)?[^\\s;]+)/g, data);\n\n  return parseParams(data, {name: r[1], uri: r[2] || r[3]});\n}\nexports.parseAOR = parseAOR;\n\nfunction parseVia(data) {\n  var r = applyRegex(/SIP\\s*\\/\\s*(\\d+\\.\\d+)\\s*\\/\\s*([\\S]+)\\s+([^\\s;:]+)(?:\\s*:\\s*(\\d+))?/g, data);\n  return parseParams(data, {version: r[1], protocol: r[2], host: r[3], port: r[4] && +r[4]});\n}\n\nfunction parseCSeq(d) {\n  var r = /(\\d+)\\s*([\\S]+)/.exec(d.s);\n  return { seq: +r[1], method: unescape(r[2]) };\n}\n\nfunction parseAuthHeader(d) {\n  var r1 = applyRegex(/([^\\s]*)\\s+/g, d);\n  var a = {scheme: r1[1]};\n\n  var r2 = applyRegex(/([^\\s,\"=]*)\\s*=\\s*([^\\s,\"]+|\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")\\s*/g, d);\n  a[r2[1]]=r2[2];\n\n  while(r2 = applyRegex(/,\\s*([^\\s,\"=]*)\\s*=\\s*([^\\s,\"]+|\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")\\s*/g, d)) {\n    a[r2[1]]=r2[2];\n  }\n\n  return a;\n}\n\nfunction parseAuthenticationInfoHeader(d) {\n  var a = {};\n  var r = applyRegex(/([^\\s,\"=]*)\\s*=\\s*([^\\s,\"]+|\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")\\s*/g, d);\n  a[r[1]]=r[2];\n\n  while(r = applyRegex(/,\\s*([^\\s,\"=]*)\\s*=\\s*([^\\s,\"]+|\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")\\s*/g, d)) {\n    a[r[1]]=r[2];\n  }\n  return a;\n}\n\nvar compactForm = {\n  i: 'call-id',\n  m: 'contact',\n  e: 'contact-encoding',\n  l: 'content-length',\n  c: 'content-type',\n  f: 'from',\n  s: 'subject',\n  k: 'supported',\n  t: 'to',\n  v: 'via'\n};\n\nvar parsers = {\n  'to': parseAOR,\n  'from': parseAOR,\n  'contact': function(v, h) {\n    if(v == '*')\n      return v;\n    else\n      return parseMultiHeader(parseAOR, v, h);\n  },\n  'route': parseMultiHeader.bind(0, parseAOR),\n  'record-route': parseMultiHeader.bind(0, parseAOR),\n  'cseq': parseCSeq,\n  'content-length': function(v) { return +v.s; },\n  'via': parseMultiHeader.bind(0, parseVia),\n  'www-authenticate': parseMultiHeader.bind(0, parseAuthHeader),\n  'proxy-authenticate': parseMultiHeader.bind(0, parseAuthHeader),\n  'authorization': parseMultiHeader.bind(0, parseAuthHeader),\n  'proxy-authorization': parseMultiHeader.bind(0, parseAuthHeader),\n  'authentication-info': parseAuthenticationInfoHeader,\n  'refer-to': parseAOR\n};\n\nfunction parse(data) {\n  data = data.split(/\\r\\n(?![ \\t])/);\n\n  if(data[0] === '')\n    return;\n\n  var m = {};\n\n  if(!(parseResponse(data[0], m) || parseRequest(data[0], m)))\n    return;\n\n  m.headers = {};\n\n  for(var i = 1; i < data.length; ++i) {\n    var r = data[i].match(/^([\\S]*?)\\s*:\\s*([\\s\\S]*)$/);\n    if(!r) {\n      return;\n    }\n\n    var name = unescape(r[1]).toLowerCase();\n    name = compactForm[name] || name;\n\n    m.headers[name] = (parsers[name] || parseGenericHeader)({s:r[2], i:0}, m.headers[name]);\n  }\n\n  return m;\n}\n\nfunction parseUri(s) {\n  if(typeof s === 'object')\n    return s;\n\n  var re = /^(sips?):(?:([^\\s>:@]+)(?::([^\\s@>]+))?@)?([\\w\\-\\.]+)(?::(\\d+))?((?:;[^\\s=\\?>;]+(?:=[^\\s?\\;]+)?)*)(\\?([^\\s&=>]+=[^\\s&=>]+)(&[^\\s&=>]+=[^\\s&=>]+)*)?$/;\n\n  var r = re.exec(s);\n\n  if(r) {\n    return {\n      schema: r[1],\n      user: r[2],\n      password: r[3],\n      host: r[4],\n      port: +r[5],\n      params: (r[6].match(/([^;=]+)(=([^;=]+))?/g) || [])\n        .map(function(s) { return s.split('='); })\n        .reduce(function(params, x) { params[x[0]]=x[1] || null; return params;}, {}),\n      headers: ((r[7] || '').match(/[^&=]+=[^&=]+/g) || [])\n        .map(function(s){ return s.split('=') })\n        .reduce(function(params, x) { params[x[0]]=x[1]; return params; }, {})\n    }\n  }\n}\n\nexports.parseUri = parseUri;\n\nfunction stringifyVersion(v) {\n  return v || '2.0';\n}\n\nfunction stringifyUri(uri) {\n  if(typeof uri === 'string')\n    return uri;\n\n  var s = (uri.schema || 'sip') + ':';\n\n  if(uri.user) {\n    if(uri.password)\n      s += uri.user + ':' + uri.password + '@';\n    else\n      s += uri.user + '@';\n  }\n\n  s += uri.host;\n\n  if(uri.port)\n    s += ':' + uri.port;\n\n  if(uri.params)\n    s += Object.keys(uri.params).map(function(x){return ';'+x+(uri.params[x] ? '='+uri.params[x] : '');}).join('');\n\n  if(uri.headers) {\n    var h = Object.keys(uri.headers).map(function(x){return x+'='+uri.headers[x];}).join('&');\n    if(h.length)\n      s += '?' + h; \n  }\n  return s;\n}\n\nexports.stringifyUri = stringifyUri;\n\nfunction stringifyParams(params) {\n  var s = '';\n  for(var n in params) {\n      s += ';'+n+(params[n]?'='+params[n]:'');\n  }\n\n  return s;\n}\n\nfunction stringifyAOR(aor) {\n  return (aor.name || '') + ' <' + stringifyUri(aor.uri) + '>'+stringifyParams(aor.params); \n}\n\nfunction stringifyAuthHeader(a) {\n  var s = [];\n\n  for(var n in a) {\n    if(n !== 'scheme' && a[n] !== undefined) {\n      s.push(n + '=' + a[n]);\n    }\n  }\n\n  return a.scheme ? a.scheme + ' ' + s.join(',') : s.join(',');\n}\n\nexports.stringifyAuthHeader = stringifyAuthHeader;\n\nvar stringifiers = {\n  via: function(h) {\n    return h.map(function(via) {\n      return 'Via: SIP/'+stringifyVersion(via.version)+'/'+via.protocol.toUpperCase()+' '+via.host+(via.port?':'+via.port:'')+stringifyParams(via.params)+'\\r\\n';\n    }).join('');\n  },\n  to: function(h) {\n    return 'To: '+stringifyAOR(h) + '\\r\\n';\n   },\n  from: function(h) {\n    return 'From: '+stringifyAOR(h)+'\\r\\n';\n  },\n  contact: function(h) { \n    return 'Contact: '+ ((h !== '*' && h.length) ? h.map(stringifyAOR).join(', ') : '*') + '\\r\\n';\n  },\n  route: function(h) {\n    return h.length ? 'Route: ' + h.map(stringifyAOR).join(', ') + '\\r\\n' : '';\n  },\n  'record-route': function(h) {\n    return h.length ? 'Record-Route: ' + h.map(stringifyAOR).join(', ') + '\\r\\n' : '';\n  },\n  cseq: function(cseq) { \n    return 'CSeq: '+cseq.seq+' '+cseq.method+'\\r\\n';\n  },\n  'www-authenticate': function(h) { \n    return h.map(function(x) { return 'WWW-Authenticate: '+stringifyAuthHeader(x)+'\\r\\n'; }).join('');\n  },\n  'proxy-authenticate': function(h) { \n    return h.map(function(x) { return 'Proxy-Authenticate: '+stringifyAuthHeader(x)+'\\r\\n'; }).join('');\n  },\n  'authorization': function(h) {\n    return h.map(function(x) { return 'Authorization: ' + stringifyAuthHeader(x) + '\\r\\n'}).join('');\n  },\n  'proxy-authorization': function(h) {\n    return h.map(function(x) { return 'Proxy-Authorization: ' + stringifyAuthHeader(x) + '\\r\\n'}).join('');; \n  },\n  'authentication-info': function(h) {\n    return 'Authentication-Info: ' + stringifyAuthHeader(h) + '\\r\\n';\n  },\n  'refer-to': function(h) { return 'Refer-To: ' + stringifyAOR(h) + '\\r\\n'; }\n};\n\nfunction stringify(m) {\n  var s;\n  if(m.status) {\n    s = 'SIP/' + stringifyVersion(m.version) + ' ' + m.status + ' ' + m.reason + '\\r\\n';\n  }\n  else {\n    s = m.method + ' ' + stringifyUri(m.uri) + ' SIP/' + stringifyVersion(m.version) + '\\r\\n';\n  }\n\n  m.headers['content-length'] = (m.content || '').length;\n\n  for(var n in m.headers) {\n    if(typeof m.headers[n] === 'string' || !stringifiers[n]) \n      s += n + ': ' + m.headers[n] + '\\r\\n';\n    else\n      s += stringifiers[n](m.headers[n], n);\n  }\n  \n  s += '\\r\\n';\n\n  if(m.content)\n    s += m.content;\n\n  return s;\n}\n\nexports.stringify = stringify;\n\nfunction makeResponse(rq, status, reason) {\n  return {\n    status: status,\n    reason: reason || '',\n    version: rq.version,\n    headers: {\n      via: rq.headers.via,\n      to: rq.headers.to,\n      from: rq.headers.from,\n      'call-id': rq.headers['call-id'],\n      cseq: rq.headers.cseq\n    }\n  };\n}\n\nexports.makeResponse = makeResponse;\n\nfunction clone(o, deep) {\n  if(typeof o === 'object') {\n    var r = Array.isArray(o) ? [] : {};\n    Object.keys(o).forEach(function(k) { r[k] = deep ? clone(o[k], deep): o[k]; });\n    return r;\n  }\n\n  return o;\n}\n\nexports.copyMessage = function(msg, deep) {\n  if(deep) return clone(msg, true);\n\n  var r = {\n    uri: deep ? clone(msg.uri, deep) : msg.uri,\n    method: msg.method,\n    status: msg.status,\n    reason: msg.reason,\n    headers: clone(msg.headers, deep),\n    content: msg.content\n  };\n\n  // always copy via array \n  r.headers.via = clone(msg.headers.via);\n\n  return r;\n}\n\nfunction makeStreamParser(onMessage) {\n  var m;\n  var r = '';\n  \n  function headers(data) {\n    r += data;\n    var a = r.match(/^\\s*([\\S\\s]*?)\\r\\n\\r\\n([\\S\\s]*)$/);\n\n    if(a) {\n      r = a[2];\n      m = parse(a[1]);\n\n      if(m && m.headers['content-length'] !== undefined) {\n        state = content;\n        content('');\n      }\n    }\n  }\n\n  function content(data) {\n    r += data;\n\n    if(r.length >= m.headers['content-length']) {\n      m.content = r.substring(0, m.headers['content-length']);\n      \n      onMessage(m);\n      \n      var s = r.substring(m.headers['content-length']);\n      state = headers;\n      r = '';\n      headers(s);\n    }\n  }\n\n  var state=headers;\n\n  return function(data) { state(data); }\n}\nexports.makeStreamParser = makeStreamParser;\n\nfunction parseMessage(s) {\n  var r = s.toString('ascii').split('\\r\\n\\r\\n');\n  if(r) {\n    var m = parse(r[0]);\n\n    if(m) {\n      if(m.headers['content-length']) {\n        var c = Math.max(0, Math.min(m.headers['content-length'], r[1].length));\n        m.content = r[1].substring(0, c);\n      }\n      else {\n        m.content = r[1];\n      }\n      \n      return m;\n    }\n  }\n}\nexports.parse = parseMessage;\n\nfunction makeTcpTransport(options, callback) {\n  var connections = Object.create(null);\n\n  function init(stream, remote) {\n    var id = [remote.address, remote.port].join(),\n        local = {protocol: 'TCP', address: stream.address().address, port: stream.address().port},\n        pending = [],\n        refs = 0;\n\n    function send(m) {\n      try {\n        if(stream.readyState === 'opening')\n          pending.push(m);\n        else\n          stream.write(m, 'ascii');\n      }\n      catch(e) {\n        process.nextTick(stream.emit.bind(stream, 'error', e));\n      }\n    }\n    \n    stream.setEncoding('ascii');\n\n    stream.on('data', makeStreamParser(function(m) { \n      if(m.method) m.headers.via[0].params.received = remote.address;\n      callback(m, remote); \n    }));\n\n    stream.on('close',    function() { delete connections[id]; });\n    stream.on('error',    function() {});\n    stream.on('end',      function() { if(refs === 0) stream.end(); });\n    stream.on('timeout',  function() { if(refs === 0) stream.end(); });\n    stream.on('connect',  function() { pending.splice(0).forEach(send); });\n    stream.setTimeout(60000);   \n \n    connections[id] = function(onError) {\n      ++refs;\n      if(onError) stream.on('error', onError);\n\n      return {\n        release: function() {\n          if(onError) stream.removeListener('error', onError);\n\n          if(--refs === 0) {\n            if(stream.readyState === 'writeOnly')\n              stream.end();\n            else\n              setTimeout(60000);\n          }\n        },\n        send: send,\n        local: local\n      }\n    };\n    \n    return connections[id];\n  }\n  \n  var server = net.createServer(function(stream) {\n    init(stream, {protocol: 'TCP', address: stream.remoteAddress, port: stream.remotePort});\n  });\n\n  server.listen(options.port || 5060, options.address);\n  \n  return {\n    open: function(remote, error, dontopen) {\n      var id = [remote.address, remote.port].join();\n\n      if(id in connections) return connections[id](error);\n\n      if(dontopen) return null;\n\n      return init(net.createConnection(remote.port, remote.address), remote)(error);\n    },\n    destroy: function() { server.close(); }\n  }\n}\n\nfunction makeUdpTransport_V0_5(options, callback) {\n  var socket = dgram.createSocket('udp4', function(data, rinfo) {\n    var msg = parseMessage(data);\n    \n    if(msg) {\n      if(msg.method) {\n        msg.headers.via[0].params.received = rinfo.address;\n        if(msg.headers.via[0].params.hasOwnProperty('rport'))\n          msg.headers.via[0].params.rport = rinfo.port;\n      }\n\n      callback(msg, {protocol: 'UDP', address: rinfo.address, port: rinfo.port});\n    }\n  });\n\n  socket.bind(options.port || 5060, options.address);\n\n  return {\n    open: function(remote, error) {\n      return {\n        send: function(m) {\n          socket.send(new Buffer(m, 'ascii'), 0, m.length, remote.port, remote.address);          \n        },\n        local: {protocol: 'UDP', address: socket.address().address, port: socket.address().port},\n        release : function() {}\n      }; \n    },\n    destroy: function() { socket.close(); }\n  }\n}\n\nfunction makeUdpTransport_pre_V0_5(options, callback) {\n  var connections = Object.create(null);\n\n  function listener(data, rinfo) {\n    var msg = parseMessage(data);\n\n    if(msg) {\n      if(msg.method) {\n        msg.headers.via[0].params.received = rinfo.address;\n        if(msg.headers.via[0].params.hasOwnProperty('rport'))\n          msg.headers.via[0].params.rport = rinfo.port;\n      }\n    \n      callback(msg, {protocol: 'UDP', address: rinfo.address, port: rinfo.port});\n    }\n  };\n\n  var socket = udp.createSocket(listener);\n\n  socket.bind(options.port || 5060, options.address);\n  socket.on('error', function() {});\n  \n  function open(remote) {\n    var socket = udp.createSocket(listener),\n        id = [remote.address, remote.port].join(),\n        local,\n        refs = 0,\n        timeout;\n    \n    socket.bind(options.port || 5060, options.address);\n    socket.connect(remote.port, remote.address);\n    \n    local = {protocol: 'UDP', address: socket.address().address, port: socket.address().port};\n    \n    socket.on('error', function() {});\n    socket.on('close', function() { delete connections[id]; });\n\n    return connections[id] = function(onError) {\n      ++refs;\n      \n      if(timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      if(onError) socket.on('error', onError);\n\n      return { \n        send: function(m) {\n          socket.send(new Buffer(m, 'ascii'), 0, m.length);\n        },\n        release: function() { \n          if(onError) socket.removeListener('error', onError);\n          \n          if(--refs === 0)\n            timeout = setTimeout(socket.close.bind(socket), 30000);\n        },\n        local: local\n      };\n    };\n  };\n \n  return {\n    open: function(remote, error) { \n      return (connections[[remote.address, remote.port].join()] || open(remote))(error);\n    },\n    destroy: function() { socket.close(); }\n  };\n}\n\nvar makeUdpTransport = v05 ? makeUdpTransport_V0_5 : makeUdpTransport_pre_V0_5; \n\nfunction makeTransport(options, callback) {\n  var protocols = {};\n\n  var callbackAndLog = callback;\n  if(options.logger && options.logger.recv) {\n    callbackAndLog = function(m, remote) {\n      options.logger.recv(m, remote);\n      callback(m, remote);\n    }\n  }\n  \n  if(options.udp === undefined || options.udp)\n    protocols.UDP = makeUdpTransport(options, callbackAndLog); \n  if(options.tcp === undefined || options.tcp)\n    protocols.TCP = makeTcpTransport(options, callbackAndLog);\n\n  function wrap(obj, target) {\n    return Object.create(obj, {send: {value: function(m) {\n      if(m.method) {\n        m.headers.via[0].host = this.local.address;\n        m.headers.via[0].port = options.port || 5060;\n        m.headers.via[0].protocol = this.local.protocol;\n\n        try {\n        if(this.local.protocol === 'UDP' && (!options.hasOwnProperty('rport') || options.rport)) {\n          m.headers.via[0].params.rport = null;\n        }\n        } catch(e) {\n          utils.debug(e);\n        }\n      }\n      options.logger && options.logger.send && options.logger.send(m, target);\n      obj.send(stringify(m));\n    }}});\n  }\n\n  return {\n    open: function(target, error) {\n      return wrap(protocols[target.protocol.toUpperCase()].open(target, error), target);\n    },\n    send: function(target, message) {\n      var cn = this.open(target);\n      try {\n        cn.send(message);\n      }\n      finally {\n        cn.release();\n      }\n    },\n    destroy: function() { \n      Object.keys(protocols).forEach(function(key) { protocols[key].destroy(); });\n    },\n  };\n}\n\nexports.makeTransport = makeTransport;\n\nfunction resolve(uri, action) {\n  if(uri.host.match(/^\\d{1,3}(\\.\\d{1,3}){3}$/))\n    return action([{protocol: uri.params.transport || 'UDP', address: uri.host, port: uri.port || 5060}]);\n\n  if(uri.port) {\n    var protocols = uri.params.protocol ? [uri.params.protocol] : ['UDP', 'TCP'];\n    \n    dns.resolve4(uri.host, function(err, address) {\n      address = (address || []).map(function(x) { return protocols.map(function(p) { return { protocol: p, address: x, port: uri.port || 5060};});})\n      .reduce(function(arr,v) { return arr.concat(v); }, []);\n      action(address);\n    });\n  }\n  else {\n    var protocols = uri.params.protocol ? [uri.params.protocol] : ['tcp', 'udp'];\n  \n    var n = protocols.length;\n    var addresses = [];\n\n    protocols.forEach(function(proto) {\n      dns.resolveSrv('_sip._'+proto+'.'+uri.host, function(e, r) {\n        --n;\n        if(Array.isArray(r)) {\n          n += r.length;\n          r.forEach(function(srv) {\n            dns.resolve4(srv.name, function(e, r) {\n              addresses = addresses.concat((r||[]).map(function(a) { return {protocol: proto, address: a, port: srv.port};}));\n            \n              if((--n)===0) // all outstanding requests has completed\n                action(addresses);\n            });\n          });\n        }\n        else if(0 === n) {\n          // all srv requests failed\n          dns.resolve4(uri.host, function(err, address) {\n            address = (address || []).map(function(x) { return protocols.map(function(p) { return { protocol: p, address: x, port: uri.port || 5060};});})\n              .reduce(function(arr,v) { return arr.concat(v); }, []);\n            action(address);\n          });\n        }\n      })\n    });\n  }\n}\n\nexports.resolve = resolve;\n\n//transaction layer\nfunction generateBranch() {\n  return ['z9hG4bK',Math.round(Math.random()*1000000)].join('');\n}\n\nexports.generateBranch = generateBranch;\n\nfunction makeSM() {\n  var state;\n\n  return {\n    enter: function(newstate) {\n      if(state && state.leave)\n        state.leave();\n      \n      state = newstate;\n      Array.prototype.shift.apply(arguments);\n      if(state.enter) \n        state.enter.apply(this, arguments);\n    },\n    signal: function(s) {\n      if(state && state[s]) \n        state[Array.prototype.shift.apply(arguments)].apply(state, arguments);\n    }\n  };\n}\n\nfunction createInviteServerTransaction(transport, cleanup) {\n  var sm = makeSM();\n  var rs;\n    \n  var proceeding = {\n    message: function() { \n      if(rs) transport(rs);\n    },\n    send: function(message) {\n      rs = message;\n\n      if(message.status >= 300)\n        sm.enter(completed);\n      else if(message.status >= 200)\n        sm.enter(accepted);\n      \n      transport(rs);\n    }\n  }\n\n  var g, h;\n  var completed = {\n    enter: function () {\n      g = setTimeout(function retry(t) { \n        setTimeout(retry, t*2, t*2);\n        transport(rs)\n      }, 500, 500);\n      h = setTimeout(sm.enter.bind(sm, terminated), 32000);\n    },\n    leave: function() {\n      clearTimeout(g);\n      clearTimeout(h);\n    },\n    message: function(m) {\n      if(m.method === 'ACK')\n        sm.enter(confirmed)\n      else\n        transport(rs);\n    }\n  }\n  \n  var confirmed = {enter: function() { setTimeout(sm.enter.bind(sm, terminated), 5000);} };\n\n  var accepted = {\n    enter: function() { setTimeout(sm.enter.bind(sm, terminated), 32000);},\n    send: function(m) { \n      rs = m;\n      transport(rs);\n    }  \n  };\n\n  var terminated = {enter: cleanup};\n  \n  sm.enter(proceeding);\n\n  return {send: sm.signal.bind(sm, 'send'), message: sm.signal.bind(sm,'message')};\n}\n\nfunction createServerTransaction(transport, cleanup) {\n  var sm = makeSM();\n  var rs;\n\n  var trying = {\n    message: function() { if(rs) transport(rs); },\n    send: function(m) {\n      rs = m;\n      transport(m);\n      if(m.status >= 200) sm.enter(completed);\n    }\n  }; \n\n  var completed = {\n    message: function() { transport(rs); },\n    enter: function() { setTimeout(cleanup, 32000); }\n  };\n\n  sm.enter(trying);\n\n  return {send: sm.signal.bind(sm, 'send'), message: sm.signal.bind(sm, 'message')};\n}\n\nfunction createInviteClientTransaction(rq, transport, tu, cleanup) {\n  var sm = makeSM();\n\n  var a, b;\n  var calling = {\n    enter: function() {\n      transport(rq);\n\n      if(!transport.reliable) {\n        a = setTimeout(function resend(t) {\n          transport(rq);\n          a = setTimeout(resend, t*2, t*2);\n        }, 500, 500);\n      }\n        \n      b = setTimeout(function() {\n        tu(makeResponse(rq, 503));\n        sm.enter(terminated);\n      }, 32000);\n    },\n    leave: function() {\n      clearTimeout(a);\n      clearTimeout(b);\n    },\n    message: function(message) {\n      tu(message);\n\n      if(message.status < 200)\n        sm.enter(proceeding);\n      else if(message.status < 300) \n         sm.enter(accepted);\n      else\n        sm.enter(completed, message);\n    }\n  };\n\n  var proceeding = {\n    message: function(message) {\n      tu(message);\n      \n      if(message.status >= 300)\n        sm.enter(completed, message);\n      else if(message.status >= 200)\n        sm.enter(accepted);\n    }\n  };\n\n  var ack = {\n    method: 'ACK',\n    uri: rq.uri,\n    headers: {\n      from: rq.headers.from,\n      cseq: {method: 'ACK', seq: rq.headers.cseq.seq},\n      'call-id': rq.headers['call-id'],\n      via: [rq.headers.via[0]]\n    }\n  };\n\n  var completed = {\n    enter: function(rs) {\n      ack.headers.to=rs.headers.to;\n      transport(ack);\n      setTimeout(sm.enter.bind(sm, terminated), 32000);\n    },\n    message: function(message, remote) {\n      if(remote) transport(ack);  // we don't want to ack internally generated messages\n    }\n  };\n\n  var accepted = {\n    enter: function() {\n      setTimeout(function() { sm.enter(terminated); }, 32000);\n    },\n    message: function(m) {\n      if(m.status >= 200 && m.status <= 299)\n        tu(message);\n    }\n  };\n\n  var terminated = {enter: cleanup};\n \n  sm.enter(calling);\n \n  return {message: sm.signal.bind(sm, 'message')};\n}\n\nfunction createClientTransaction(rq, transport, tu, cleanup) {  \n  assert.ok(rq.method !== 'INVITE');\n\n  var sm = makeSM();\n  \n  var e, f;\n  var trying = {\n    enter: function() { \n      transport(rq);\n      if(!transport.reliable)\n        e = setTimeout(function() { sm.signal('timerE', 500); }, 500);\n      f = setTimeout(function() { sm.signal('timerF'); }, 32000);\n    },\n    leave: function() {\n      clearTimeout(e);\n      clearTimeout(f);\n    },\n    message: function(message, remote) {\n      if(message.status >= 200)\n        sm.enter(completed);\n      else\n        sm.enter(proceeding);\n      tu(message);\n    },\n    timerE: function(t) {\n      transport(rq);\n      e = setTimeout(function() { sm.signal('timerE', t*2); }, t*2);\n    },\n    timerF: function() {\n      tu(makeResponse(rq, 503));\n      sm.enter(terminated);\n    }\n  };\n\n  var proceeding = {\n    message: function(message, remote) {\n      if(message.status >= 200)\n        sm.enter(completed);\n      tu(message);\n    }\n  };\n\n  var completed = {enter: function () { setTimeout(function() { sm.enter(terminated); }, 5000); } };\n\n  var terminated = {enter: cleanup};\n\n  sm.enter(trying);\n\n  return {message: sm.signal.bind(sm, 'message')};\n}\n\nfunction makeTransactionId(m) {\n  if(m.method === 'ACK')\n    return ['INVITE', m.headers['call-id'], m.headers.via[0].params.branch].join();\n  return [m.headers.cseq.method, m.headers['call-id'], m.headers.via[0].params.branch].join();\n}\n \nfunction makeTransactionLayer(options, transport) {\n  var server_transactions = Object.create(null);\n  var client_transactions = Object.create(null);\n\n  return {\n    createServerTransaction: function(rq, remote) {\n      var id = makeTransactionId(rq);\n      \n      if(remote.protocol === 'UDP' && !rq.headers.via[0].params.hasOwnProperty('rport'))\n        remote = {protocol: 'UDP', port: rq.headers.via[0].port || 5060, address: remote.address};\n\n      var cn = transport(remote, function() {}, true);\n      return server_transactions[id] = (rq.method === 'INVITE' ? createInviteServerTransaction : createServerTransaction)(\n        cn.send.bind(cn),\n        function() { \n          delete server_transactions[id];\n          cn.release();\n        });\n    },\n    createClientTransaction: function(rq, callback) {\n      if(rq.method !== 'CANCEL') {\n        if(rq.headers.via)\n          rq.headers.via.unshift({params:{}});\n        else\n          rq.headers.via = [{params:{}}];\n      }\n      \n      if(typeof rq.headers.cseq !== 'object')\n        rq.headers.cseq = parseCSeq({s: rq.headers.cseq, i:0});\n\n      var transaction = rq.method === 'INVITE' ? createInviteClientTransaction : createClientTransaction;\n\n      var hop = parseUri(rq.uri);\n\n      if(rq.headers.route) {\n        if(typeof rq.headers.route === 'string')\n          rq.headers.route = parsers.route({s: rq.headers.route, i:0});\n\n        hop = parseUri(rq.headers.route[0].uri);\n        if(hop.params.lr === undefined ) {\n          rq.headers.route.shift();\n          rq.headers.route.push({uri: rq.uri});\n          rq.uri = hop;\n        }\n      }\n\n      resolve(hop, function(address) {\n        var onresponse;\n\n        function next() {\n          onresponse = searching;\n          if(address.length > 0) {\n            try {\n              if(rq.method !== 'CANCEL')\n                rq.headers.via[0].params.branch = generateBranch();\n \n              var id = makeTransactionId(rq);\n\n              var cn = transport(address.shift(), function(e) { client_transactions[id].message(makeResponse(rq, 503));}); \n              var send = cn.send.bind(cn);\n              send.reliable = cn.local.protocol.toUpperCase() !== 'UDP';\n\n              client_transactions[id] = transaction(rq, send, onresponse, function() { \n                delete client_transactions[id];\n                cn.release();\n              });\n            }\n            catch(e) {\n              callback(makeResponse(rq, 503));  \n            }\n          }\n          else\n            callback(makeResponse(rq, 404));\n        }\n\n        function searching(rs) {\n          if(rs.status === 503)\n            next();\n          else if(rs.status > 100) {\n            onresponse = callback;\n        }\n        \n        callback(rs);\n      }\n\n      next();\n    });\n  },\n  getServer: function(m) {\n    return server_transactions[makeTransactionId(m)];\n  },\n  getClient: function(m) {\n    return client_transactions[makeTransactionId(m)];\n  }};\n}\n\nexports.makeTransactionLayer = makeTransactionLayer;\n\nexports.create = function(options, callback) {\n  var errorLog = (options.logger && options.logger.error) || function() {};\n\n  var transport = makeTransport(options, function(m,remote) {\n    try {\n      var t = m.method ? transaction.getServer(m) : transaction.getClient(m);\n\n      if(!t) {\n        if(m.method && m.method !== 'ACK') {\n          var t = transaction.createServerTransaction(m,remote);\n          try {\n            callback(m,remote);\n          } catch(e) {\n            t.send(makeResponse(m, '500', 'Internal Server Error'));\n            throw e;\n          } \n        }\n        else if(m.method === 'ACK') {\n          callback(m,remote);\n        }\n      }\n      else {\n        t.message && t.message(m, remote);\n      }\n    } \n    catch(e) {\n      errorLog(e);\n    }\n  });\n  \n  var transaction = makeTransactionLayer(options, transport.open.bind(transport));\n\n  return {\n    send: function(m, callback) {\n      if(m.method === undefined) {\n        var t = transaction.getServer(m);\n        t && t.send && t.send(m);\n      }\n      else {\n        if(m.method === 'ACK') {\n          if(m.headers.via === undefined)\n            m.headers.via = [];\n\n          m.headers.via.unshift({params: {branch: generateBranch()}});\n          \n          resolve(parseUri(m.uri), function(address) {\n            if(address.length === 0) {\n              errorLog(new Error(\"ACK: couldn't resove\" + stringifyUri(m.uri)));\n              return;\n            }\n          \n            var cn = transport.open(address[0], errorLog);\n            try {\n              cn.send(m);\n            } \n            catch(e) {\n              errorLog(e);\n            }\n            finally {\n              cn.release();\n            }\n          });\n        }\n        else {\n          return transaction.createClientTransaction(m, callback || function() {});\n        }\n      }\n    },\n    destroy: transport.destroy.bind(transport)\n  } \n}\n\nexports.start = function(options, callback) {\n  var r = exports.create(options, callback);\n\n  exports.send = r.send;\n  exports.stop = r.destroy;\n}\n\n"]],"start1":0,"start2":0,"length1":0,"length2":32330}]],"length":32330}
