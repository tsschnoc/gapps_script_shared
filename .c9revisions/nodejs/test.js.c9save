{"ts":1350921788690,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var https = require('https');\r\nvar url = require('url');\r\n\r\nvar authHeaders = {}\r\n\r\nfunction doAuth() {\r\n    var payload = 'Email=thomas.schnocklake@gmail.com&Passwd=k3%256%24ts&accountType=GOOG&source=Google-cURL-Example&service=writely';\r\n    var options = {\r\n        host: 'www.google.com',\r\n        port: 443,\r\n        path: '/accounts/ClientLogin',\r\n        method: 'POST',\r\n        headers: {\r\n            Accept: \"*/*\",\r\n            \"GData-Version\": \"3.0\",\r\n            \"If-match\": \"*\",\r\n            \"content-length\": payload.length,\r\n            \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n            \"accept\": \"*/*\",\r\n        },\r\n    };\r\n\r\n    var req = https.request(options, function(res) {\r\n        console.log(\"statusCode: \", res.statusCode);\r\n//        console.log(\"headers: \", res.headers);\r\n        res.on('data', onAuth);\r\n    });\r\n\r\n\r\n    req.on('error', onErr);\r\n    req.write(payload);\r\n    req.end();\r\n}\r\n\r\nfunction onErr(e) {\r\n    console.error(e);\r\n}\r\n\r\nfunction onAuth(d) {\r\n    var s = \"\";\r\n    for (var v in d) {\r\n        s += String.fromCharCode(d[v]);\r\n    }\r\n\r\n    var auth = s;\r\n    auth = auth.substring(auth.indexOf(\"Auth=\") + 5, auth.length - 1);\r\n    process.stdout.write(auth);\r\n\r\n    authHeaders = {\r\n        \"Accept\": \"*/*\",\r\n        \"GData-Version\": \"3.0\",\r\n        \"Authorization\": \"GoogleLogin Auth=\" + auth,\r\n    };\r\n    fetchDocs();\r\n}\r\n\r\nvar responseString = \"\";\r\n\r\nfunction fetchDocs() {\r\n    var options = {\r\n        host: 'docs.google.com',\r\n        port: 443,\r\n        path: '/feeds/default/private/full/-/%7Bhttp%3A%2F%2Fschemas.google.com%2Fg%2F2005%23kind%7Dimage%2Fjpeg?alt=json&q=owner%3Athomas.schnocklake%40googlemail.com+-exif&max-results=3',\r\n        method: 'GET',\r\n        headers: authHeaders,\r\n    };\r\n    var req = https.request(options, function(res) {\r\n        console.log(\"statusCode: \", res.statusCode);\r\n        res.on('data', onFetchDocsData);\r\n        res.on('end', onFetchDocsEnd);\r\n    });\r\n\r\n    req.on('error', onErr);\r\n    req.end();\r\n}\r\n\r\nfunction onFetchDocsData(d) {\r\n    var x = d.toString();\r\n    responseString += x;\r\n}\r\n\r\n\r\nfunction onFetchDocsEnd() {\r\n\r\n    var obj = JSON.parse(responseString);\r\n    //    process.stdout.write(JSON.stringify(obj));\r\n    for (var i in obj.feed.entry) {\r\n        var documentListEntry = obj.feed.entry[i];\r\n\r\n        var options = url.parse(documentListEntry.content.src);\r\n        options.method= 'GET';\r\n        options['If-match']= \"*\";\r\n        options.headers = {};\r\n        options.headers.Accept = authHeaders.Accept;\r\n        options.headers.Authorization = authHeaders.Authorization;\r\n        options.headers['GData-Version'] = authHeaders['GData-Version'];\r\n        \r\n        options.headers.Range= \"bytes=0-9999\";\r\n        console.log(\"documentListEntry: \" + documentListEntry.id.$t);\r\n\r\n        doRequest(options, documentListEntry);     \r\n    }\r\n}\r\n\r\n\r\n  function doRequest(options, documentListEntry)\r\n  {\r\n    var req = https.request(options, function(res) {contentResponse(res, documentListEntry);});        \r\n    req.on('error', onErr);\r\n    req.end();                \r\n  }\r\n\r\n\r\n\r\nfunction contentResponse(res,dle) {\r\n  console.log(\"statusCode: \", res.statusCode);\r\n  //            console.log(\"headers: \", res.headers);\r\n  var data = new Buffer(10000);\r\n  var off = 0;\r\n  res.on('data', function(chunk) {\r\n    chunk.copy(data, off);\r\n    off += chunk.length;\r\n\r\n    console.log(off);\r\n    console.log(\"dls: \" + dle.id.$t);\r\n  });\r\n\r\n  res.on('end', function() {\r\n    onSourceReceivedEnd(data, dle);\r\n  });\r\n}\r\n\r\nfunction onSourceReceivedEnd(data, documentListEntry1) {\r\n//    console.log(\"onEditLinkDate data: \" + data.length);\r\n//    console.log(\"onEditLinkDate documentListEntry1 docs$md5Checksum: \" + JSON.stringify(documentListEntry1.docs$md5Checksum.$t,null,'\\t'));\r\n\r\n    console.log(data.toString(\"base64\") );\r\n    \r\n    \r\n    var BinaryFile = LoadBinLib();\r\n    var EXIF = initExifLib();\r\n    \r\n    var binFile = new BinaryFile(data);\r\n        \r\n    var exif = EXIF.readFromBinaryFile(binFile);\r\n    console.log(exif );\r\n    \r\n    \r\n    var desc = {};\r\n    desc.md5sum = documentListEntry1.docs$md5Checksum.$t;\r\n    \r\n    console.log(\"onSourceReceivedEnd: \" + documentListEntry1.id.$t);\r\n    \r\n    for (var m in exif) {\r\n      if (typeof exif[m] == \"object\") {\r\n        var s = \"\";\r\n        for (var v in exif[m]) {s += String.fromCharCode(exif[m][v]);}\r\n        delete exif[m];\r\n      }\r\n    }\r\n \r\n    desc.exif = exif;\r\n    \r\n    \r\n    // http://nodejs.org/api.html#_child_processes\r\nvar exec = require('child_process').exec;\r\nvar child;\r\n\r\n// executes `pwd`\r\nchild = exec(\"exiftool -G -j -\", function (error, stdout, stderr) {\r\n  console.log('stdout: ' + stdout);\r\n  console.log('stderr: ' + stderr);\r\n  if (error !== null) {\r\n    console.log('exec error: ' + error);\r\n  }\r\n});\r\n    \r\nchild.stdin.write(data);\r\nchild.stdin.end();\r\n\r\n    \r\n    \r\n    return;\r\n//    console.log(desc);\r\n    var editLink;\r\n    for (var j in documentListEntry1.link) {\r\n      if (documentListEntry1.link[j].rel == 'edit') {\r\n        editLink = documentListEntry1.link[j];\r\n      }\r\n    }\r\n    //console.log(editLink);\r\n    \r\n    var payload =  '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\r\n    payload += '<entry xmlns=\"http://www.w3.org/2005/Atom\" xmlns:docs=\"http://schemas.google.com/docs/2007\"><docs:description>' + JSON.stringify(desc,null, \"\\t\") + '</docs:description></entry>';\r\n\r\n    var options = url.parse(editLink.href);\r\n    \r\n    options.method= 'PUT';    \r\n    options.headers = {};\r\n    options.headers['If-match']= \"*\";\r\n    options.headers.Accept = authHeaders.Accept;\r\n    options.headers.Authorization = authHeaders.Authorization;\r\n    options.headers['GData-Version'] = authHeaders['GData-Version'];\r\n    options.headers['content-length'] = payload.length;\r\n    options.headers['content-type'] = \"application/atom+xml; charset=UTF-8\";\r\n\r\n\r\n    var req = https.request(options, function(res) {\r\n        console.log(\"statusCode: \", res.statusCode);\r\n        //console.log(\"update headers: \", res.headers);\r\n        \r\n        \r\n        \r\n            res.on('data', function(chunk) { \r\n             \r\n              \r\n          //    console.log(chunk.toString());\r\n            }) ;\r\n        \r\n         \r\n    });\r\n\r\n    req.on('error', onErr);\r\n\r\n    req.write(payload);\r\n    req.end();\r\n  \r\n}\r\n\r\n\r\ndoAuth();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n\r\nObject.prototype.clone = function() {\r\n  var newObj = (this instanceof Array) ? [] : {};\r\n  for (var ix in this) {\r\n    if (ix == 'clone') continue;\r\n    if (this[ix] && typeof this[ix] == \"object\") {\r\n      newObj[ix] = this[i].clone();\r\n    } else newObj[ix] = this[ix]\r\n  } return newObj;\r\n};\r\n\r\n*/\r\n\r\nfunction LoadBinLib() {  \r\n/*\r\n * Binary Ajax 0.1.10\r\n * Copyright (c) 2008 Jacob Seidelin, cupboy@gmail.com, http://blog.nihilogic.dk/\r\n * Licensed under the MPL License [http://www.nihilogic.dk/licenses/mpl-license.txt]\r\n */\r\n\r\n  \r\n  var BinaryFile = function(strData, iDataOffset, iDataLength) {\r\n//    var data = strData;\r\n    var data = new Buffer(strData.length);\r\n    strData.copy(data);\r\n    \r\n    \r\n    var dataOffset = iDataOffset || 0;\r\n    var dataLength = 0;\r\n    \r\n    this.getRawData = function() {\r\n      return data;\r\n    }\r\n    \r\n  \r\n    dataLength = iDataLength || data.length;\r\n\r\n        this.getByteAt = function(iOffset) {\r\n          var bb = data[iOffset];\r\n/*          if (bb < 0) {\r\n            bb = bb + 256;\r\n          }\r\n*/          \r\n          return bb;\r\n        }\r\n        \r\n        this.getBytesAt = function(iOffset, iLength) {\r\n            var aBytes = [];\r\n            \r\n            for (var i = 0; i < iLength; i++) {\r\n              var bb = data[iOffset + i];\r\n/*              \r\n              if (bb < 0) {\r\n                bb = bb + 256;\r\n              }\r\n*/              \r\n              aBytes[i] = bb;\r\n            };\r\n            \r\n            return aBytes;\r\n        }\r\n    \r\n\r\n/*\r\nif (typeof strData == \"string\") {\r\n        dataLength = iDataLength || data.length;\r\n\r\n        this.getByteAt = function(iOffset) {\r\n            return data.charCodeAt(iOffset + dataOffset) & 0xFF;\r\n        }\r\n        \r\n        this.getBytesAt = function(iOffset, iLength) {\r\n            var aBytes = [];\r\n            \r\n            for (var i = 0; i < iLength; i++) {\r\n                aBytes[i] = data.charCodeAt((iOffset + i) + dataOffset) & 0xFF\r\n            };\r\n            \r\n            return aBytes;\r\n        }\r\n    } else if (typeof strData == \"unknown\") {\r\n        dataLength = iDataLength || IEBinary_getLength(data);\r\n\r\n        this.getByteAt = function(iOffset) {\r\n            return IEBinary_getByteAt(data, iOffset + dataOffset);\r\n        }\r\n\r\n        this.getBytesAt = function(iOffset, iLength) {\r\n            return new VBArray(IEBinary_getBytesAt(data, iOffset + dataOffset, iLength)).toArray();\r\n        }\r\n    }\r\n*/\r\n    this.getLength = function() {\r\n        return dataLength;\r\n    }\r\n\r\n    this.getSByteAt = function(iOffset) {\r\n        var iByte = this.getByteAt(iOffset);\r\n        if (iByte > 127)\r\n            return iByte - 256;\r\n        else\r\n            return iByte;\r\n    }\r\n\r\n    this.getShortAt = function(iOffset, bBigEndian) {\r\n        var iShort = bBigEndian ? \r\n            (this.getByteAt(iOffset) << 8) + this.getByteAt(iOffset + 1)\r\n            : (this.getByteAt(iOffset + 1) << 8) + this.getByteAt(iOffset)\r\n        if (iShort < 0) iShort += 65536;\r\n        return iShort;\r\n    }\r\n    this.getSShortAt = function(iOffset, bBigEndian) {\r\n        var iUShort = this.getShortAt(iOffset, bBigEndian);\r\n        if (iUShort > 32767)\r\n            return iUShort - 65536;\r\n        else\r\n            return iUShort;\r\n    }\r\n    this.getLongAt = function(iOffset, bBigEndian) {\r\n        var iByte1 = this.getByteAt(iOffset),\r\n            iByte2 = this.getByteAt(iOffset + 1),\r\n            iByte3 = this.getByteAt(iOffset + 2),\r\n            iByte4 = this.getByteAt(iOffset + 3);\r\n\r\n        var iLong = bBigEndian ? \r\n            (((((iByte1 << 8) + iByte2) << 8) + iByte3) << 8) + iByte4\r\n            : (((((iByte4 << 8) + iByte3) << 8) + iByte2) << 8) + iByte1;\r\n        if (iLong < 0) iLong += 4294967296;\r\n        return iLong;\r\n    }\r\n    this.getSLongAt = function(iOffset, bBigEndian) {\r\n        var iULong = this.getLongAt(iOffset, bBigEndian);\r\n        if (iULong > 2147483647)\r\n            return iULong - 4294967296;\r\n        else\r\n            return iULong;\r\n    }\r\n\r\n    this.getStringAt = function(iOffset, iLength) {\r\n        var aStr = [];\r\n        \r\n        var aBytes = this.getBytesAt(iOffset, iLength);\r\n        for (var j=0; j < iLength; j++) {\r\n            aStr[j] = String.fromCharCode(aBytes[j]);\r\n        }\r\n        return aStr.join(\"\");\r\n    }\r\n    \r\n    this.getCharAt = function(iOffset) {\r\n        return String.fromCharCode(this.getByteAt(iOffset));\r\n    }\r\n    this.toBase64 = function() {\r\n        return window.btoa(data);\r\n    }\r\n    this.fromBase64 = function(strBase64) {\r\n        data = window.atob(strBase64);\r\n    }\r\n}\r\n\r\n\r\nreturn BinaryFile;\r\n}\r\n\r\n\r\nfunction initExifLib() {\r\n/*\r\n * Javascript EXIF Reader 0.1.4\r\n * Copyright (c) 2008 Jacob Seidelin, cupboy@gmail.com, http://blog.nihilogic.dk/\r\n * Licensed under the MPL License [http://www.nihilogic.dk/licenses/mpl-license.txt]\r\n */\r\n\r\n\r\nvar EXIF = {};\r\n\r\n(function() {\r\n\r\nvar bDebug = false;\r\n\r\nEXIF.Tags = {\r\n\r\n  // version tags\r\n    0x9000 : \"ExifVersion\",         // EXIF version\r\n    0xA000 : \"FlashpixVersion\",     // Flashpix format version\r\n\r\n    // colorspace tags\r\n    0xA001 : \"ColorSpace\",          // Color space information tag\r\n\r\n    // image configuration\r\n    0xA002 : \"PixelXDimension\",     // Valid width of meaningful image\r\n    0xA003 : \"PixelYDimension\",     // Valid height of meaningful image\r\n    0x9101 : \"ComponentsConfiguration\", // Information about channels\r\n    0x9102 : \"CompressedBitsPerPixel\",  // Compressed bits per pixel\r\n\r\n    // user information\r\n    0x927C : \"MakerNote\",           // Any desired information written by the manufacturer\r\n    0x9286 : \"UserComment\",         // Comments by user\r\n\r\n    // related file\r\n    0xA004 : \"RelatedSoundFile\",        // Name of related sound file\r\n\r\n    // date and time\r\n    0x9003 : \"DateTimeOriginal\",        // Date and time when the original image was generated\r\n    0x9004 : \"DateTimeDigitized\",       // Date and time when the image was stored digitally\r\n    0x9290 : \"SubsecTime\",          // Fractions of seconds for DateTime\r\n    0x9291 : \"SubsecTimeOriginal\",      // Fractions of seconds for DateTimeOriginal\r\n    0x9292 : \"SubsecTimeDigitized\",     // Fractions of seconds for DateTimeDigitized\r\n\r\n    // picture-taking conditions\r\n    0x829A : \"ExposureTime\",        // Exposure time (in seconds)\r\n    0x829D : \"FNumber\",         // F number\r\n    0x8822 : \"ExposureProgram\",     // Exposure program\r\n    0x8824 : \"SpectralSensitivity\",     // Spectral sensitivity\r\n    0x8827 : \"ISOSpeedRatings\",     // ISO speed rating\r\n    0x8828 : \"OECF\",            // Optoelectric conversion factor\r\n    0x9201 : \"ShutterSpeedValue\",       // Shutter speed\r\n    0x9202 : \"ApertureValue\",       // Lens aperture\r\n    0x9203 : \"BrightnessValue\",     // Value of brightness\r\n    0x9204 : \"ExposureBias\",        // Exposure bias\r\n    0x9205 : \"MaxApertureValue\",        // Smallest F number of lens\r\n    0x9206 : \"SubjectDistance\",     // Distance to subject in meters\r\n    0x9207 : \"MeteringMode\",        // Metering mode\r\n    0x9208 : \"LightSource\",         // Kind of light source\r\n    0x9209 : \"Flash\",           // Flash status\r\n    0x9214 : \"SubjectArea\",         // Location and area of main subject\r\n    0x920A : \"FocalLength\",         // Focal length of the lens in mm\r\n    0xA20B : \"FlashEnergy\",         // Strobe energy in BCPS\r\n    0xA20C : \"SpatialFrequencyResponse\",    // \r\n    0xA20E : \"FocalPlaneXResolution\",   // Number of pixels in width direction per FocalPlaneResolutionUnit\r\n    0xA20F : \"FocalPlaneYResolution\",   // Number of pixels in height direction per FocalPlaneResolutionUnit\r\n    0xA210 : \"FocalPlaneResolutionUnit\",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\r\n    0xA214 : \"SubjectLocation\",     // Location of subject in image\r\n    0xA215 : \"ExposureIndex\",       // Exposure index selected on camera\r\n    0xA217 : \"SensingMethod\",       // Image sensor type\r\n    0xA300 : \"FileSource\",          // Image source (3 == DSC)\r\n    0xA301 : \"SceneType\",           // Scene type (1 == directly photographed)\r\n    0xA302 : \"CFAPattern\",          // Color filter array geometric pattern\r\n    0xA401 : \"CustomRendered\",      // Special processing\r\n    0xA402 : \"ExposureMode\",        // Exposure mode\r\n    0xA403 : \"WhiteBalance\",        // 1 = auto white balance, 2 = manual\r\n    0xA404 : \"DigitalZoomRation\",       // Digital zoom ratio\r\n    0xA405 : \"FocalLengthIn35mmFilm\",   // Equivalent foacl length assuming 35mm film camera (in mm)\r\n    0xA406 : \"SceneCaptureType\",        // Type of scene\r\n    0xA407 : \"GainControl\",         // Degree of overall image gain adjustment\r\n    0xA408 : \"Contrast\",            // Direction of contrast processing applied by camera\r\n    0xA409 : \"Saturation\",          // Direction of saturation processing applied by camera\r\n    0xA40A : \"Sharpness\",           // Direction of sharpness processing applied by camera\r\n    0xA40B : \"DeviceSettingDescription\",    // \r\n    0xA40C : \"SubjectDistanceRange\",    // Distance to subject\r\n\r\n    // other tags\r\n    0xA005 : \"InteroperabilityIFDPointer\",\r\n    0xA420 : \"ImageUniqueID\"        // Identifier assigned uniquely to each image\r\n};\r\n\r\nEXIF.TiffTags = {\r\n    0x0100 : \"ImageWidth\",\r\n    0x0101 : \"ImageHeight\",\r\n    0x8769 : \"ExifIFDPointer\",\r\n    0x8825 : \"GPSInfoIFDPointer\",\r\n    0xA005 : \"InteroperabilityIFDPointer\",\r\n    0x0102 : \"BitsPerSample\",\r\n    0x0103 : \"Compression\",\r\n    0x0106 : \"PhotometricInterpretation\",\r\n    0x0112 : \"Orientation\",\r\n    0x0115 : \"SamplesPerPixel\",\r\n    0x011C : \"PlanarConfiguration\",\r\n    0x0212 : \"YCbCrSubSampling\",\r\n    0x0213 : \"YCbCrPositioning\",\r\n    0x011A : \"XResolution\",\r\n    0x011B : \"YResolution\",\r\n    0x0128 : \"ResolutionUnit\",\r\n    0x0111 : \"StripOffsets\",\r\n    0x0116 : \"RowsPerStrip\",\r\n    0x0117 : \"StripByteCounts\",\r\n    0x0201 : \"JPEGInterchangeFormat\",\r\n    0x0202 : \"JPEGInterchangeFormatLength\",\r\n    0x012D : \"TransferFunction\",\r\n    0x013E : \"WhitePoint\",\r\n    0x013F : \"PrimaryChromaticities\",\r\n    0x0211 : \"YCbCrCoefficients\",\r\n    0x0214 : \"ReferenceBlackWhite\",\r\n    0x0132 : \"DateTime\",\r\n    0x010E : \"ImageDescription\",\r\n    0x010F : \"Make\",\r\n    0x0110 : \"Model\",\r\n    0x0131 : \"Software\",\r\n    0x013B : \"Artist\",\r\n    0x8298 : \"Copyright\"\r\n}\r\n\r\nEXIF.GPSTags = {\r\n    0x0000 : \"GPSVersionID\",\r\n    0x0001 : \"GPSLatitudeRef\",\r\n    0x0002 : \"GPSLatitude\",\r\n    0x0003 : \"GPSLongitudeRef\",\r\n    0x0004 : \"GPSLongitude\",\r\n    0x0005 : \"GPSAltitudeRef\",\r\n    0x0006 : \"GPSAltitude\",\r\n    0x0007 : \"GPSTimeStamp\",\r\n    0x0008 : \"GPSSatellites\",\r\n    0x0009 : \"GPSStatus\",\r\n    0x000A : \"GPSMeasureMode\",\r\n    0x000B : \"GPSDOP\",\r\n    0x000C : \"GPSSpeedRef\",\r\n    0x000D : \"GPSSpeed\",\r\n    0x000E : \"GPSTrackRef\",\r\n    0x000F : \"GPSTrack\",\r\n    0x0010 : \"GPSImgDirectionRef\",\r\n    0x0011 : \"GPSImgDirection\",\r\n    0x0012 : \"GPSMapDatum\",\r\n    0x0013 : \"GPSDestLatitudeRef\",\r\n    0x0014 : \"GPSDestLatitude\",\r\n    0x0015 : \"GPSDestLongitudeRef\",\r\n    0x0016 : \"GPSDestLongitude\",\r\n    0x0017 : \"GPSDestBearingRef\",\r\n    0x0018 : \"GPSDestBearing\",\r\n    0x0019 : \"GPSDestDistanceRef\",\r\n    0x001A : \"GPSDestDistance\",\r\n    0x001B : \"GPSProcessingMethod\",\r\n    0x001C : \"GPSAreaInformation\",\r\n    0x001D : \"GPSDateStamp\",\r\n    0x001E : \"GPSDifferential\"\r\n}\r\n\r\nEXIF.StringValues = {\r\n    ExposureProgram : {\r\n        0 : \"Not defined\",\r\n        1 : \"Manual\",\r\n        2 : \"Normal program\",\r\n        3 : \"Aperture priority\",\r\n        4 : \"Shutter priority\",\r\n        5 : \"Creative program\",\r\n        6 : \"Action program\",\r\n        7 : \"Portrait mode\",\r\n        8 : \"Landscape mode\"\r\n    },\r\n    MeteringMode : {\r\n        0 : \"Unknown\",\r\n        1 : \"Average\",\r\n        2 : \"CenterWeightedAverage\",\r\n        3 : \"Spot\",\r\n        4 : \"MultiSpot\",\r\n        5 : \"Pattern\",\r\n        6 : \"Partial\",\r\n        255 : \"Other\"\r\n    },\r\n    LightSource : {\r\n        0 : \"Unknown\",\r\n        1 : \"Daylight\",\r\n        2 : \"Fluorescent\",\r\n        3 : \"Tungsten (incandescent light)\",\r\n        4 : \"Flash\",\r\n        9 : \"Fine weather\",\r\n        10 : \"Cloudy weather\",\r\n        11 : \"Shade\",\r\n        12 : \"Daylight fluorescent (D 5700 - 7100K)\",\r\n        13 : \"Day white fluorescent (N 4600 - 5400K)\",\r\n        14 : \"Cool white fluorescent (W 3900 - 4500K)\",\r\n        15 : \"White fluorescent (WW 3200 - 3700K)\",\r\n        17 : \"Standard light A\",\r\n        18 : \"Standard light B\",\r\n        19 : \"Standard light C\",\r\n        20 : \"D55\",\r\n        21 : \"D65\",\r\n        22 : \"D75\",\r\n        23 : \"D50\",\r\n        24 : \"ISO studio tungsten\",\r\n        255 : \"Other\"\r\n    },\r\n    Flash : {\r\n        0x0000 : \"Flash did not fire\",\r\n        0x0001 : \"Flash fired\",\r\n        0x0005 : \"Strobe return light not detected\",\r\n        0x0007 : \"Strobe return light detected\",\r\n        0x0009 : \"Flash fired, compulsory flash mode\",\r\n        0x000D : \"Flash fired, compulsory flash mode, return light not detected\",\r\n        0x000F : \"Flash fired, compulsory flash mode, return light detected\",\r\n        0x0010 : \"Flash did not fire, compulsory flash mode\",\r\n        0x0018 : \"Flash did not fire, auto mode\",\r\n        0x0019 : \"Flash fired, auto mode\",\r\n        0x001D : \"Flash fired, auto mode, return light not detected\",\r\n        0x001F : \"Flash fired, auto mode, return light detected\",\r\n        0x0020 : \"No flash function\",\r\n        0x0041 : \"Flash fired, red-eye reduction mode\",\r\n        0x0045 : \"Flash fired, red-eye reduction mode, return light not detected\",\r\n        0x0047 : \"Flash fired, red-eye reduction mode, return light detected\",\r\n        0x0049 : \"Flash fired, compulsory flash mode, red-eye reduction mode\",\r\n        0x004D : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\r\n        0x004F : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\r\n        0x0059 : \"Flash fired, auto mode, red-eye reduction mode\",\r\n        0x005D : \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\r\n        0x005F : \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\r\n    },\r\n    SensingMethod : {\r\n        1 : \"Not defined\",\r\n        2 : \"One-chip color area sensor\",\r\n        3 : \"Two-chip color area sensor\",\r\n        4 : \"Three-chip color area sensor\",\r\n        5 : \"Color sequential area sensor\",\r\n        7 : \"Trilinear sensor\",\r\n        8 : \"Color sequential linear sensor\"\r\n    },\r\n    SceneCaptureType : {\r\n        0 : \"Standard\",\r\n        1 : \"Landscape\",\r\n        2 : \"Portrait\",\r\n        3 : \"Night scene\"\r\n    },\r\n    SceneType : {\r\n        1 : \"Directly photographed\"\r\n    },\r\n    CustomRendered : {\r\n        0 : \"Normal process\",\r\n        1 : \"Custom process\"\r\n    },\r\n    WhiteBalance : {\r\n        0 : \"Auto white balance\",\r\n        1 : \"Manual white balance\"\r\n    },\r\n    GainControl : {\r\n        0 : \"None\",\r\n        1 : \"Low gain up\",\r\n        2 : \"High gain up\",\r\n        3 : \"Low gain down\",\r\n        4 : \"High gain down\"\r\n    },\r\n    Contrast : {\r\n        0 : \"Normal\",\r\n        1 : \"Soft\",\r\n        2 : \"Hard\"\r\n    },\r\n    Saturation : {\r\n        0 : \"Normal\",\r\n        1 : \"Low saturation\",\r\n        2 : \"High saturation\"\r\n    },\r\n    Sharpness : {\r\n        0 : \"Normal\",\r\n        1 : \"Soft\",\r\n        2 : \"Hard\"\r\n    },\r\n    SubjectDistanceRange : {\r\n        0 : \"Unknown\",\r\n        1 : \"Macro\",\r\n        2 : \"Close view\",\r\n        3 : \"Distant view\"\r\n    },\r\n    FileSource : {\r\n        3 : \"DSC\"\r\n    },\r\n\r\n    Components : {\r\n        0 : \"\",\r\n        1 : \"Y\",\r\n        2 : \"Cb\",\r\n        3 : \"Cr\",\r\n        4 : \"R\",\r\n        5 : \"G\",\r\n        6 : \"B\"\r\n    }\r\n}\r\n\r\nfunction addEvent(oElement, strEvent, fncHandler) \r\n{\r\n    if (oElement.addEventListener) { \r\n        oElement.addEventListener(strEvent, fncHandler, false); \r\n    } else if (oElement.attachEvent) { \r\n        oElement.attachEvent(\"on\" + strEvent, fncHandler); \r\n    }\r\n}\r\n\r\n\r\nfunction imageHasData(oImg) \r\n{\r\n    return !!(oImg.exifdata);\r\n}\r\n\r\nfunction getImageData(oImg, fncCallback) \r\n{\r\n    BinaryAjax(\r\n        oImg.src,\r\n        function(oHTTP) {\r\n            var oEXIF = findEXIFinJPEG(oHTTP.binaryResponse);\r\n            oImg.exifdata = oEXIF || {};\r\n            if (fncCallback) fncCallback();\r\n        }\r\n    )\r\n}\r\n\r\nfunction findEXIFinJPEG(oFile) {\r\n    var aMarkers = [];\r\n\r\n    if (oFile.getByteAt(0) != 0xFF || oFile.getByteAt(1) != 0xD8) {\r\n        return false; // not a valid jpeg\r\n    }\r\n\r\n    var iOffset = 2;\r\n    var iLength = oFile.getLength();\r\n    while (iOffset < iLength) {\r\n        if (oFile.getByteAt(iOffset) != 0xFF) {\r\n            if (bDebug) console.log(\"Not a valid marker at offset \" + iOffset + \", found: \" + oFile.getByteAt(iOffset));\r\n            return false; // not a valid marker, something is wrong\r\n        }\r\n\r\n        var iMarker = oFile.getByteAt(iOffset+1);\r\n\r\n        // we could implement handling for other markers here, \r\n        // but we're only looking for 0xFFE1 for EXIF data\r\n\r\n        if (iMarker == 22400) {\r\n            if (bDebug) console.log(\"Found 0xFFE1 marker\");\r\n            return readEXIFData(oFile, iOffset + 4, oFile.getShortAt(iOffset+2, true)-2);\r\n            iOffset += 2 + oFile.getShortAt(iOffset+2, true);\r\n\r\n        } else if (iMarker == 225) {\r\n            // 0xE1 = Application-specific 1 (for EXIF)\r\n            if (bDebug) console.log(\"Found 0xFFE1 marker\");\r\n            return readEXIFData(oFile, iOffset + 4, oFile.getShortAt(iOffset+2, true)-2);\r\n\r\n        } else {\r\n            iOffset += 2 + oFile.getShortAt(iOffset+2, true);\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction readTags(oFile, iTIFFStart, iDirStart, oStrings, bBigEnd) \r\n{\r\n    var iEntries = oFile.getShortAt(iDirStart, bBigEnd);\r\n    var oTags = {};\r\n    for (var i=0;i<iEntries;i++) {\r\n        var iEntryOffset = iDirStart + i*12 + 2;\r\n        var strTag = oStrings[oFile.getShortAt(iEntryOffset, bBigEnd)];\r\n        if (!strTag && bDebug) console.log(\"Unknown tag: \" + oFile.getShortAt(iEntryOffset, bBigEnd));\r\n        oTags[strTag] = readTagValue(oFile, iEntryOffset, iTIFFStart, iDirStart, bBigEnd);\r\n    }\r\n    return oTags;\r\n}\r\n\r\n\r\nfunction readTagValue(oFile, iEntryOffset, iTIFFStart, iDirStart, bBigEnd)\r\n{\r\n    var iType = oFile.getShortAt(iEntryOffset+2, bBigEnd);\r\n    var iNumValues = oFile.getLongAt(iEntryOffset+4, bBigEnd);\r\n    var iValueOffset = oFile.getLongAt(iEntryOffset+8, bBigEnd) + iTIFFStart;\r\n\r\n    switch (iType) {\r\n        case 1: // byte, 8-bit unsigned int\r\n        case 7: // undefined, 8-bit byte, value depending on field\r\n            if (iNumValues == 1) {\r\n                return oFile.getByteAt(iEntryOffset + 8, bBigEnd);\r\n            } else {\r\n                var iValOffset = iNumValues > 4 ? iValueOffset : (iEntryOffset + 8);\r\n                var aVals = [];\r\n                for (var n=0;n<iNumValues;n++) {\r\n                    aVals[n] = oFile.getByteAt(iValOffset + n);\r\n                }\r\n                return aVals;\r\n            }\r\n            break;\r\n\r\n        case 2: // ascii, 8-bit byte\r\n            var iStringOffset = iNumValues > 4 ? iValueOffset : (iEntryOffset + 8);\r\n            return oFile.getStringAt(iStringOffset, iNumValues-1);\r\n            break;\r\n\r\n        case 3: // short, 16 bit int\r\n            if (iNumValues == 1) {\r\n                return oFile.getShortAt(iEntryOffset + 8, bBigEnd);\r\n            } else {\r\n                var iValOffset = iNumValues > 2 ? iValueOffset : (iEntryOffset + 8);\r\n                var aVals = [];\r\n                for (var n=0;n<iNumValues;n++) {\r\n                    aVals[n] = oFile.getShortAt(iValOffset + 2*n, bBigEnd);\r\n                }\r\n                return aVals;\r\n            }\r\n            break;\r\n\r\n        case 4: // long, 32 bit int\r\n            if (iNumValues == 1) {\r\n                return oFile.getLongAt(iEntryOffset + 8, bBigEnd);\r\n            } else {\r\n                var aVals = [];\r\n                for (var n=0;n<iNumValues;n++) {\r\n                    aVals[n] = oFile.getLongAt(iValueOffset + 4*n, bBigEnd);\r\n                }\r\n                return aVals;\r\n            }\r\n            break;\r\n        case 5: // rational = two long values, first is numerator, second is denominator\r\n            if (iNumValues == 1) {\r\n                return oFile.getLongAt(iValueOffset, bBigEnd) / oFile.getLongAt(iValueOffset+4, bBigEnd);\r\n            } else {\r\n                var aVals = [];\r\n                for (var n=0;n<iNumValues;n++) {\r\n                    aVals[n] = oFile.getLongAt(iValueOffset + 8*n, bBigEnd) / oFile.getLongAt(iValueOffset+4 + 8*n, bBigEnd);\r\n                }\r\n                return aVals;\r\n            }\r\n            break;\r\n        case 9: // slong, 32 bit signed int\r\n            if (iNumValues == 1) {\r\n                return oFile.getSLongAt(iEntryOffset + 8, bBigEnd);\r\n            } else {\r\n                var aVals = [];\r\n                for (var n=0;n<iNumValues;n++) {\r\n                    aVals[n] = oFile.getSLongAt(iValueOffset + 4*n, bBigEnd);\r\n                }\r\n                return aVals;\r\n            }\r\n            break;\r\n        case 10: // signed rational, two slongs, first is numerator, second is denominator\r\n            if (iNumValues == 1) {\r\n                return oFile.getSLongAt(iValueOffset, bBigEnd) / oFile.getSLongAt(iValueOffset+4, bBigEnd);\r\n            } else {\r\n                var aVals = [];\r\n                for (var n=0;n<iNumValues;n++) {\r\n                    aVals[n] = oFile.getSLongAt(iValueOffset + 8*n, bBigEnd) / oFile.getSLongAt(iValueOffset+4 + 8*n, bBigEnd);\r\n                }\r\n                return aVals;\r\n            }\r\n            break;\r\n    }\r\n}\r\n\r\n\r\nfunction readEXIFData(oFile, iStart, iLength) \r\n{\r\n    if (oFile.getStringAt(iStart, 4) != \"Exif\") {\r\n        if (bDebug) console.log(\"Not valid EXIF data! \" + oFile.getStringAt(iStart, 4));\r\n        return false;\r\n    }\r\n\r\n    var bBigEnd;\r\n\r\n    var iTIFFOffset = iStart + 6;\r\n\r\n    // test for TIFF validity and endianness\r\n    if (oFile.getShortAt(iTIFFOffset) == 0x4949) {\r\n        bBigEnd = false;\r\n    } else if (oFile.getShortAt(iTIFFOffset) == 0x4D4D) {\r\n        bBigEnd = true;\r\n    } else {\r\n        if (bDebug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\r\n        return false;\r\n    }\r\n\r\n    if (oFile.getShortAt(iTIFFOffset+2, bBigEnd) != 0x002A) {\r\n        if (bDebug) console.log(\"Not valid TIFF data! (no 0x002A)\");\r\n        return false;\r\n    }\r\n\r\n    if (oFile.getLongAt(iTIFFOffset+4, bBigEnd) != 0x00000008) {\r\n        if (bDebug) console.log(\"Not valid TIFF data! (First offset not 8)\", oFile.getShortAt(iTIFFOffset+4, bBigEnd));\r\n        return false;\r\n    }\r\n\r\n    var oTags = readTags(oFile, iTIFFOffset, iTIFFOffset+8, EXIF.TiffTags, bBigEnd);\r\n\r\n    if (oTags.ExifIFDPointer) {\r\n        var oEXIFTags = readTags(oFile, iTIFFOffset, iTIFFOffset + oTags.ExifIFDPointer, EXIF.Tags, bBigEnd);\r\n        for (var strTag in oEXIFTags) {\r\n            switch (strTag) {\r\n                case \"LightSource\" :\r\n                case \"Flash\" :\r\n                case \"MeteringMode\" :\r\n                case \"ExposureProgram\" :\r\n                case \"SensingMethod\" :\r\n                case \"SceneCaptureType\" :\r\n                case \"SceneType\" :\r\n                case \"CustomRendered\" :\r\n                case \"WhiteBalance\" : \r\n                case \"GainControl\" : \r\n                case \"Contrast\" :\r\n                case \"Saturation\" :\r\n                case \"Sharpness\" : \r\n                case \"SubjectDistanceRange\" :\r\n                case \"FileSource\" :\r\n                    oEXIFTags[strTag] = EXIF.StringValues[strTag][oEXIFTags[strTag]];\r\n                    break;\r\n    \r\n                case \"ExifVersion\" :\r\n                case \"FlashpixVersion\" :\r\n                    oEXIFTags[strTag] = String.fromCharCode(oEXIFTags[strTag][0], oEXIFTags[strTag][1], oEXIFTags[strTag][2], oEXIFTags[strTag][3]);\r\n                    break;\r\n    \r\n                case \"ComponentsConfiguration\" : \r\n                    oEXIFTags[strTag] = \r\n                        EXIF.StringValues.Components[oEXIFTags[strTag][0]]\r\n                        + EXIF.StringValues.Components[oEXIFTags[strTag][1]]\r\n                        + EXIF.StringValues.Components[oEXIFTags[strTag][2]]\r\n                        + EXIF.StringValues.Components[oEXIFTags[strTag][3]];\r\n                    break;\r\n            }\r\n            oTags[strTag] = oEXIFTags[strTag];\r\n        }\r\n    }\r\n\r\n    if (oTags.GPSInfoIFDPointer) {\r\n        var oGPSTags = readTags(oFile, iTIFFOffset, iTIFFOffset + oTags.GPSInfoIFDPointer, EXIF.GPSTags, bBigEnd);\r\n        for (var strTag in oGPSTags) {\r\n            switch (strTag) {\r\n                case \"GPSVersionID\" : \r\n                    oGPSTags[strTag] = oGPSTags[strTag][0] \r\n                        + \".\" + oGPSTags[strTag][1] \r\n                        + \".\" + oGPSTags[strTag][2] \r\n                        + \".\" + oGPSTags[strTag][3];\r\n                    break;\r\n            }\r\n            oTags[strTag] = oGPSTags[strTag];\r\n        }\r\n    }\r\n\r\n    return oTags;\r\n}\r\n\r\n\r\nEXIF.getData = function(oImg, fncCallback) \r\n{\r\n    if (!oImg.complete) return false;\r\n    if (!imageHasData(oImg)) {\r\n        getImageData(oImg, fncCallback);\r\n    } else {\r\n        if (fncCallback) fncCallback();\r\n    }\r\n    return true;\r\n}\r\n\r\nEXIF.getTag = function(oImg, strTag) \r\n{\r\n    if (!imageHasData(oImg)) return;\r\n    return oImg.exifdata[strTag];\r\n}\r\n\r\nEXIF.getAllTags = function(oImg) \r\n{\r\n    if (!imageHasData(oImg)) return {};\r\n    var oData = oImg.exifdata;\r\n    var oAllTags = {};\r\n    for (var a in oData) {\r\n        if (oData.hasOwnProperty(a)) {\r\n            oAllTags[a] = oData[a];\r\n        }\r\n    }\r\n    return oAllTags;\r\n}\r\n\r\n\r\nEXIF.pretty = function(oImg) \r\n{\r\n    if (!imageHasData(oImg)) return \"\";\r\n    var oData = oImg.exifdata;\r\n    var strPretty = \"\";\r\n    for (var a in oData) {\r\n        if (oData.hasOwnProperty(a)) {\r\n            if (typeof oData[a] == \"object\") {\r\n                strPretty += a + \" : [\" + oData[a].length + \" values]\\r\\n\";\r\n            } else {\r\n                strPretty += a + \" : \" + oData[a] + \"\\r\\n\";\r\n            }\r\n        }\r\n    }\r\n    return strPretty;\r\n}\r\n\r\nEXIF.readFromBinaryFile = function(oFile) {\r\n    return findEXIFinJPEG(oFile);\r\n}\r\n\r\nfunction loadAllImages() \r\n{\r\n    var aImages = document.getElementsByTagName(\"img\");\r\n    for (var i=0;i<aImages.length;i++) {\r\n        if (aImages[i].getAttribute(\"exif\") == \"true\") {\r\n            if (!aImages[i].complete) {\r\n                addEvent(aImages[i], \"load\", \r\n                    function() {\r\n                        EXIF.getData(this);\r\n                    }\r\n                ); \r\n            } else {\r\n                EXIF.getData(aImages[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n})();\r\n\r\n  \r\n  return EXIF;\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":33229}]],"length":33229}
